<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="theme-color" content="#2052BB">
<meta name="author" content="Bartosz Ciechanowski">
<meta name="format-detection" content="telephone=no">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-25335284-3"></script>


<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-25335284-3');
</script>
  <meta property="og:title" content="Curves and Surfaces – Bartosz Ciechanowski" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ciechanow.ski/curves-and-surfaces/" />
<meta property="og:description" content="Interactive article explaining how curves and surfaces are modeled." />
<meta property="og:image" content="https://ciechanow.ski/images/og/curves.jpg" />
<meta name="twitter:title" content="Curves and Surfaces – Bartosz Ciechanowski" />
<meta name="twitter:site" content="@BCiechanowski" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://ciechanow.ski/images/og/curves.jpg" />
<meta property="og:locale" content="en_US">
    <meta name="keywords" content="bezier,b-spline,nurbs,subdivision,catmull,clark,curvature,continuity,c0,c1,c2">
  <link href="../css/base.css" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Lato:700&display=swap" rel="stylesheet" type="text/css" async>
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,500&display=swap" rel="stylesheet" async>
  <title>Curves and Surfaces – Bartosz Ciechanowski</title>
  <link rel="icon" href="../favicon.ico">
  <link href="../css/curves.css" rel="stylesheet" type="text/css" />
  <script defer src="../js/base.js"></script>
  <script defer src="../js/curves.js"></script>
</head>

<body>
  <div id="main_container">
    <div id="body">
      <div id="banner">
    <div id="banner_wrapper">
        <div id="banner_content">
            <div id="site_title">
                <a href="../index.html">Bartosz Ciechanowski</a>
            </div>
            <div id="navigation">
                <a href="../index.html">Blog</a>
                <a href="../archives.html">Archives</a>
            </div>
            <div id="social">
                <a class="patreon" href="https://www.patreon.com/ciechanowski" title="Patreon"><div class="patreonLogo">Patreon</div></a>
                <a class="twitter" href="https://twitter.com/bciechanowski" title="X / Twitter"><div class="twitterLogo">X / Twitter</div></a>
                <a class="instagram" href="https://www.instagram.com/bartoszciechanowski/" title="Instagram"><div class="igLogo">Instagram</div></a>
                <a class="email" href="mailto:bartosz@ciechanow.ski" title="e-mail"><div class="emailLogo">e-mail</div></a>
                <a class="rss" href="../atom.xml" title="RSS"><div class="rssLogo">RSS</div></a>
            </div>
        </div>
    </div>
</div>

      <div id="content">
        
<div class="article">
    <div class="post_date">November 2, 2021</div>
    <h1 class="post_title"><a href="index.html">Curves and Surfaces</a></h1>
    <div class="padding_wrapper"><p>From fonts to animated movies, curves and surfaces constitute fundamental building blocks of many geometrical designs. Over the course of this blog post I&rsquo;ll explain how this model of a mask can be very smooth despite being described by a limited number of small points <span class="control_point"></span> that you can drag around to change the mask&rsquo;s shape:</p>
<div class="drawer_container ratio_100" id="cs_subdiv_hero"></div>
<p>Moreover, we&rsquo;ll see how surfaces like that are a natural extension of plain two dimensional curves like the one below:</p>
<div class="drawer_container full_width ratio_30" id="cs_curve_hero"></div>
<p>Throughout this article I&rsquo;ll keep jumping back and forth between curves and surfaces to highlight how the ideas we develop for wiggly lines can be expanded onto three dimensional shells that we can shape.</p>
<h1 id="defining-the-shape">Defining the Shape<a href="index.html#defining-the-shape" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Before we build complicated curves and surfaces we first have to decide how we&rsquo;d like to control their shape. There are many ways to describe and mold these objects, but some of those ways are better than others. In the demonstration below I built a system that lets you change the shape of a <span class="text_red"><strong>curve</strong></span> by controlling its <span style="color:#000;"><strong>spiral‑ness</strong></span> and <span class="text_yellow"><strong>size</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_spiral"></div>
<div class="slider_black" id="cs_spiral_sl0"></div>
<div class="slider_s" id="cs_spiral_sl1"></div>
<p>While fun to play with, this system is quite impractical. We can&rsquo;t control where exactly the curve ends and we also have a very limited influence on <em>how</em> it twists. For instance, it&rsquo;s impossible to create an S‑shaped curve using these controls.</p>
<p>Ideally, we&rsquo;d deal with a system that would let us directly affect where the curve is placed, while also providing a convenient control over its entire shape. These are the features that <em>control points</em> provide. Their visual placement makes it very easy to define the shape of a curve. In the demonstration below you can drag each control point shown as <span class="control_point"></span> to change the <span class="text_red"><strong>curve&rsquo;s</strong></span> form:</p>
<div class="drawer_container full_width ratio_50" id="cs_control_points"></div>
<p>Control points are often visualized with connecting lines that join them to their neighbors. This helps to avoid ambiguities when two different points <a href="index.html#" class="link_button" onclick="control_points_swap();return false;">swap their positions</a> which can make the curve look quite different.</p>
<p>Notice that all control points seem to affect the shape of the curve in the point&rsquo;s vicinity. We can visualize the impact of a given point using red color. In the demonstration below you can <span class="tap_word">tap</span><span class="click_word">click</span> a control point to see how it affects the local shape – the <span class="text_red"><strong>redder</strong></span> the section of the curve the more influenced it is by that control point. <span style="color:#aaa"><strong>Gray</strong></span> sections don&rsquo;t move at all when the selected point is dragged:</p>
<div class="drawer_container full_width ratio_50" id="cs_control_points2"></div>
<p>With control points we can easily change where the curve starts, ends, and how it flows in the middle. Moreover, the shape of the lines connecting the control points roughly resembles the shape of the resulting curve. This system of control points is simple, yet very powerful.</p>
<p>So far I&rsquo;ve been quite vague about the rules driving the shape of the resulting curve and the extent to which the control points affect it. I&rsquo;ll try to explain those underlying principles by building this system from a ground up. We&rsquo;ll also see how those ideas extend to surfaces, but before we construct these more complex elements we&rsquo;ll start with the simplest curve – a linear segment.</p>
<h1 id="linear-segment">Linear Segment<a href="index.html#linear-segment" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>In the demonstration below you can drag the control points <strong>A</strong> and <strong>B</strong> around to change their position. The slider controls a virtual <span class="text_red"><strong>red pen</strong></span> that is used to draw a segment between those two points:</p>
<div class="drawer_container full_width ratio_50" id="cs_linear_segment"></div>
<div class="slider_red" id="cs_linear_segment_sl0"></div>
<p>While this demo is the world&rsquo;s most primitive drawing application, there are some important observations we can make here already. The <span class="text_red"><strong>slider</strong></span> controls the <em>progress</em> of our drawing – the more advanced the slider is the further into drawing we are. For the <a href="index.html#" class="link_button" onclick="progress_50();return false;">progress of 0.5</a> we&rsquo;re halfway through a drawing, and at the <a href="index.html#" class="link_button" onclick="progress_90();return false;">progress of 0.9</a> we&rsquo;re mostly done.</p>
<p>Additionally, a point on the segment <a href="index.html#" class="link_button" onclick="progress_99();return false;">very close</a> to point <strong>B</strong>, as shown by the tip of the pen, moves very little when point <strong>A</strong> is dragged, but it moves a lot when point <strong>B</strong> is dragged.</p>
<p>We can visualize the &ldquo;weight&rdquo; of a given control point on the curve using the red tinting we&rsquo;ve seen before. You can <span class="tap_word">tap</span><span class="click_word">click</span> the control points to change which one is selected:</p>
<div class="drawer_container full_width ratio_50" id="cs_linear_weight_color"></div>
<p>For a linear segment like that, weighting function is quite straightforward. The closer to the control point we are the more impactful it is. Let&rsquo;s try to put some numbers behind these dependencies.</p>
<p>There are many ways to specify the impact of a control point at a distance, but the simplest approach is to assume that those weights are changing proportionally with that distance. As we <span style="color:#000;"><strong>progress</strong></span> through the curve using the slider we decrease the weight of the point <strong>A</strong> and increase the weight of the point <strong>B</strong>:</p>
<div class="drawer_container full_width ratio_50" id="cs_linear_segment_weight_plot"></div>
<div class="slider_black" id="cs_linear_segment_weight_plot_sl0"></div>
<p>This hopefully makes intuitive sense. When we&rsquo;re <a href="index.html#" class="link_button" onclick="linear_segment_weight_plot_1();return false;">all the way</a> through the curve the weight of the point <strong>A</strong> is 0 and we can move it around all we want without affecting the position of the end of the curve.</p>
<p>We can describe those little plots using some equations. A word <strong>&ldquo;progress&rdquo;</strong> would make the formulas very long so I&rsquo;ll replace it with the traditionally used letter <strong>t</strong>:</p>
<div class="equation">
t = progress
</div>
<p>The position of any point <strong>P</strong> on the linear segment for given progress <strong>t</strong> is:</p>
<div class="equation">
<div>P = A &times; (1 &minus; t) + B &times; t</div>
</div>
<p>We&rsquo;ll see those <strong>(1 − t)</strong> and <strong>t</strong> terms a lot, so to make them easier to distinguish I&rsquo;ll <span class="rounded_bg cs_blue_bg"><strong>mark them</strong></span> and I&rsquo;ll put little triangles on their right sides to quickly visualize if that section goes up or down with the progress – those triangles match the shapes of the plots we&rsquo;ve just seen:</p>
<div class="equation">
<div>P = A &times; <div class="nt"></div> + B &times; <div class="t"></div></div>
</div>
<p>This equation describes <a href="https://en.wikipedia.org/wiki/Linear_interpolation"><em>linear interpolation</em></a> and it will be very important in our further discussions. We can indeed verify that e.g. plugging progress <strong>t</strong> equal to 1 simply returns the point <strong>B</strong>.</p>
<p>It may not be immediately clear what it means to multiply a point by a number so let&rsquo;s explore that a little. Ultimately, each point has <strong>x</strong> and <strong>y</strong> coordinates that define its position relative to some origin:</p>
<div class="drawer_container full_width ratio_50" id="cs_point_coords"></div>
<p>When we multiply a point by some number we&rsquo;re actually individually multiplying its <strong>x</strong> and <strong>y</strong> coordinates:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    <div>P<sub>x</sub></div>
    </td>
    <td class="equation_center">
    <div> = </div>
    </td>
    <td>A<sub>x</sub></td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>B<sub>x</sub></td><td>&times;</td><td><div class="t"></div></td>
</tr>
<tr>
    <td class="equation_lhs">
    <div>P<sub>y</sub></div>
    </td>
    <td class="equation_center">
    <div> = </div>
    </td>
    <td>A<sub>y</sub></td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>B<sub>y</sub></td><td>&times;</td><td><div class="t"></div></td>
</tr>
</table>
</div>
<p>We can see that process in a visual form by tracking the coordinates of all three points as the <span class="text_black"><strong>progress</strong></span> changes:</p>
<div class="drawer_container full_width ratio_50" id="cs_linear_segment_coords"></div>
<div class="slider_black" id="cs_linear_segment_coords_sl0"></div>
<div class="equation" id ="cs_point_coords_equation">
<table>
<tr>
    <td class="equation_lhs">
    <div>P<sub>x</sub></div>
    </td>
    <td class="equation_center">
    <div> = </div>
    </td>
    <td>
        <div class="linear_segment_coords">
            <span id="linear_segment_coords_ax"></span>
            <div class="linear_segment_coords_badge">A<sub>x</sub></div>
        </div>
    </td>
    <td>&times;</td>
    <td>(1.00 &minus;</td>
    <td><div class="linear_segment_coords">
            <span id="linear_segment_coords_t0"></span>
            <div class="linear_segment_coords_badge">t</div>
        </div>
    </td>
    <td class="no_left_pad">)</td><td>+</td>
        <td>
        <div class="linear_segment_coords">
            <span id="linear_segment_coords_bx"></span>
            <div class="linear_segment_coords_badge">B<sub>x</sub></div>
        </div>
    </td>
    <td>&times;</td>
      <td><div class="linear_segment_coords">
            <span id="linear_segment_coords_t1"></span>
            <div class="linear_segment_coords_badge">t</div>
        </div>
    </td>
    <td>=</td>
    <td  id="linear_segment_coords_px"></td>
</tr>
<tr>
    <td class="equation_lhs">
    <div>P<sub>y</sub></div>
    </td>
    <td class="equation_center">
    <div> = </div>
    </td>
    <td>
        <div class="linear_segment_coords">
            <span id="linear_segment_coords_ay"></span>
            <div class="linear_segment_coords_badge">A<sub>y</sub></div>
        </div>
    </td>
    <td>&times;</td>
    <td>(1.00 &minus;</td>
    <td><div class="linear_segment_coords">
            <span id="linear_segment_coords_t2"></span>
            <div class="linear_segment_coords_badge">t</div>
        </div>
    </td>
    <td class="no_left_pad">)</td><td>+</td>
        <td>
        <div class="linear_segment_coords">
            <span id="linear_segment_coords_by"></span>
            <div class="linear_segment_coords_badge">B<sub>y</sub></div>
        </div>
    </td>
    <td>&times;</td>
      <td><div class="linear_segment_coords">
            <span id="linear_segment_coords_t3"></span>
            <div class="linear_segment_coords_badge">t</div>
        </div>
    </td>
    <td>=</td>
    <td  id="linear_segment_coords_py"></td>
</tr>
</table>
</div>
<p>The entire <span class="text_red"><strong>linear segment</strong></span> itself is ultimately created by infinitely many points constructed from all possible values of <strong>t</strong> between 0 and 1.</p>
<h1 id="a-step-further">A Step Further<a href="index.html#a-step-further" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>So far we&rsquo;ve been dealing with flat 2D segments, but nothing prevents us from doing the same operations in a three dimensional space. In the demonstration below you can control the position of points <strong>A</strong> and <strong>B</strong> in a 3D space by dragging them around. You can also change the viewing angle by dragging anywhere else. The <span class="text_red"><strong>slider</strong></span> controls a virtual pen that paints a <span class="text_red"><strong>linear segment</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_linear_segment_3d"></div>
<div class="slider_red" id="cs_linear_segment_3d_sl0"></div>
<p>By dragging that point through space we&rsquo;ve created a simple linear segment placed in three dimensions. However, now we can go a step further by dragging that segment through space to create a <span class="text_red"><strong>red surface</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_surface"></div>
<div class="slider_red" id="cs_surface_sl0"></div>
<p>The surface we&rsquo;ve just made is fairly arbitrary and not very well defined, but the concept is very promising, so let&rsquo;s try to create a simple surface that we can easily control. The idea is simple – we can place two linear segments in space that will form <span class="text_blue"><strong>rails</strong></span> on which another <span class="text_yellow"><strong>dragged segment</strong></span> slides:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch"></div>
<div class="slider_t" id="cs_linear_patch_sl0"></div>
<p>Notice that in <a href="index.html#" class="link_button" onclick="linear_patch_f0();return false;">many configurations</a> the <span class="text_yellow"><strong>dragged segment</strong></span> will change its length as it goes, but that is actually beneficial – it lets us create more varied shapes.</p>
<p>It&rsquo;s important to note that we move along the side segments proportionally – when we&rsquo;re <a href="index.html#" class="link_button" onclick="linear_patch_f1();return false;">halfway through dragging</a> we&rsquo;re also halfway through the lengths of the <span class="text_blue"><strong>rails</strong></span>, even if the <span class="text_blue"><strong>rails</strong></span> themselves have <a href="index.html#" class="link_button" onclick="linear_patch_f2();return false;">different lengths</a>. You can think of the <span class="text_blue"><strong>blue rails</strong></span> as a sort of interconnected sliders.</p>
<p>Let&rsquo;s not forget that the segment we&rsquo;re dragging is itself made by dragging a point between the segment&rsquo;s endpoints, so the entire surface consists of points made from all possible values of <em>two</em> different progresses, one <span class="text_blue"><strong>along the rails</strong></span> and another <span class="text_yellow"><strong>along the dragged segment</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_point"></div>
<div class="slider_t" id="cs_linear_patch_point_sl0"></div>
<div class="slider_s" id="cs_linear_patch_point_sl1"></div>
<p>The sliders, and thus the progresses, are independent of each other, so we can think of the choice they offer as a 1×1 square:</p>
<div id="square_container" class="drawer_container ratio_100">
<div>
<div id="cs_square_sl1" class="slider_s"></div><div class="drawer_container ratio_100" id="cs_square"></div>
</div>
<div>
<div id="cs_square_square"></div><div id="cs_square_sl0" class="slider_t"></div>
</div>
</div>
<p>One slider controls the progress <strong>t</strong> of the dragged segment and the other slider controls the progress <strong>s</strong> <em>within</em> that segment.</p>
<p>That arrangement of sliders is a bit cumbersome, so I&rsquo;ll just keep both of them in a horizontal orientation. I&rsquo;ll occasionally put a smaller version of this square in the bottom left corner of a demonstration – it will make it easier to analyze how the sliders control the placement of a <span class="text_black"><strong>point</strong></span> on the surface:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_point2"></div>
<div class="slider_t" id="cs_linear_patch_point2_sl1"></div>
<div class="slider_s" id="cs_linear_patch_point2_sl0"></div>
<p>It may also be useful to see how different arrangements of the control points deform that input square in the 3D space. As you deform the surface the lines remain straight, but the distances between them may change:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_point3"></div>
<div class="slider_t" id="cs_linear_patch_point3_sl1"></div>
<div class="slider_s" id="cs_linear_patch_point3_sl0"></div>
<p>Let&rsquo;s try to express what we&rsquo;ve built so far in a mathematical manner. Let me show the initial demonstration with different points labeled to makes things easier to reference:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_point4"></div>
<div class="slider_t" id="cs_linear_patch_point4_sl0"></div>
<div class="slider_s" id="cs_linear_patch_point4_sl1"></div>
<p>The end points <strong>P<sub>0</sub></strong> and <strong>P<sub>1</sub></strong> of the <span class="text_yellow"><strong>dragged segment</strong></span> are just interpolated end points of the <span class="text_blue"><strong>rails</strong></span> <strong>AC</strong> and <strong>BD</strong>:</p>
<div class="equation">
<div>P<sub>0</sub> = A &times; <div class="nt"></div> + C &times; <div class="t"></div></div>
<div>P<sub>1</sub> = B &times; <div class="nt"></div> + D &times; <div class="t"></div></div>
</div>
<p>Then the position of the point within the segment is just another linear interpolation:</p>
<div class="equation">
<div>P = P<sub>0</sub> &times; <div class="ns"></div> + P<sub>1</sub> &times; <div class="s"></div></div>
</div>
<p>After plugging the values we can indeed confirm that the final position of a point <strong>P</strong> on this surface depends on <em>two</em> parameters <strong>s</strong> and <strong>t</strong>:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    <div>P</div>
    </td>
    <td class="equation_center">
    <div> = </div>
    </td>
    <td class="no_right_pad">
    (</td><td class="no_left_pad">A</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>C</td><td>&times;</td><td><div class="t"></div></td><td class="no_left_pad">)</td><td>&times;</td><td><div class="ns"></div></td><td>+
    </td>
</tr>
<tr>
    <td></td><td></td>
    <td class="no_right_pad">
    (</td><td class="no_left_pad">B</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>D</td><td>&times;</td><td><div class="t"></div></td><td class="no_left_pad">)</td><td>&times;</td><td><div class="s"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>Which we can expand to see the functions driving each point:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="ns"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>B</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="s"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>C</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="ns"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>D</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="s"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>The terms next to the control points may seem a little complicated, but in fact they&rsquo;re fairly simple once represented visually. They are the 2D equivalents of the 1D weighting functions we&rsquo;ve already seen. I&rsquo;m once again using <span class="text_red"><strong>redness</strong></span> <em>and</em> height to visualize how impactful that control point is on different areas of the surface:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_hats"></div>
<div class="slider_t" id="cs_linear_patch_hats_sl0"></div>
<div class="slider_s" id="cs_linear_patch_hats_sl1"></div>
<p>Notice that the weighting functions are symmetrical to each other. As a result, we can create the very same surface by choosing to drag either the <span class="text_yellow"><strong>yellow</strong></span> <em>or</em> the <span class="text_blue"><strong>blue</strong></span> segment through space – they both end up tracing the same surface:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_symmetry"></div>
<div class="slider_t" id="cs_linear_patch_symmetry_sl1"></div>
<div class="slider_s" id="cs_linear_patch_symmetry_sl0"></div>
<p>While we&rsquo;re effectively just dragging a straight stick through the air, the surface it creates, known as a <a href="https://en.wikipedia.org/wiki/Paraboloid#Hyperbolic_paraboloid"><em>hyperbolic paraboloid</em></a>, at some viewing angles <a href="index.html#" class="link_button" onclick="linear_patch_symmetry_f0();return false;">doesn&rsquo;t look straight</a> at all – there are some curvy shapes to be found on this surface.</p>
<p>In general case any point sliding on the surface traces some sort of curve through space. However, a particularly interesting curve appears when a point moves across the diagonal of the input square region – we can easily show the <span class="text_red"><strong>trajectory</strong></span>  of that <span class="text_black"><strong>point</strong></span> by locking the two sliders together:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_quad_curve"></div>
<div class="slider_t" id="cs_linear_patch_quad_curve_sl1"></div>
<div class="slider_s" id="cs_linear_patch_quad_curve_sl0"></div>
<p>Notice that while the <span class="text_black"><strong>point</strong></span> always follows the same straight linear path on the input square, for <a href="index.html#" class="link_button" onclick="linear_patch_quad_curve_f0();return false;">many configurations</a> the <span class="text_red"><strong>path traced</strong></span> on the surface forms a <em>non</em>‑straight <span class="text_red"><strong>curve</strong></span>. Let&rsquo;s try to write the equation of that <span class="text_red"><strong>curve</strong></span>. To recap, any point on the surface we&rsquo;ve looked at can be described using the following equations:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="ns"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>B</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="ns"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>C</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="s"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>D</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="s"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>However, because the sliders are locked together, <strong>s</strong> and <strong>t</strong> are the same so we obtain:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>B</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>C</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="t"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>D</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>Notice that both B and C points have the same weights so we can tie them together:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td class="equation_right">A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>(B + C)</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td class="equation_right">D</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>We can simplify things even further if we make points <strong>B</strong> and <strong>C</strong> overlap each other. Observe that this makes the entire surface flat and the curve gets nicely isolated:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_quad_curve_flat"></div>
<div class="slider_black" id="cs_linear_patch_quad_curve_flat_sl0"></div>
<p>Since points <strong>B</strong> and <strong>C</strong> are the same, this gives us the final simplified form:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>1</td><td>&times;</td><td class="equation_right">A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>2</td><td>&times;</td><td>B</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>1</td><td>&times;</td><td class="equation_right">D</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>Note that we&rsquo;re dealing with just three points so from now on I&rsquo;ll call the third point <strong>C</strong> instead of <strong>D</strong>. The curve we&rsquo;ve built is known as a <em>quadratic <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve</a></em>. Here it is being drawn in just two dimensions:</p>
<div class="drawer_container full_width ratio_50" id="cs_quad_curve"></div>
<div class="slider_red" id="cs_quad_curve_sl0"></div>
<p>I think it&rsquo;s very gratifying that we&rsquo;ve found this smooth curve hiding on the surface obtained by dragging a <em>straight</em> segment through space.</p>
<p>Let&rsquo;s look at how much each point affects the shape of the curve as we <span class="text_black"><strong>advance</strong></span> through it. You can <span class="tap_word">tap</span><span class="click_word">click</span> a control point to select it:</p>
<div class="drawer_container full_width ratio_50" id="cs_quad_curve_plot"></div>
<div class="slider_black" id="cs_quad_curve_plot_sl0"></div>
<p>There are a few interesting observations to be made here:</p>
<ul>
<li>When the <span class="text_black"><strong>progress</strong></span> is <a href="index.html#" class="link_button" onclick="quad_curve_plot_f0();return false;">equal to 0</a> the weight function of control point <strong>A</strong> reaches 1 and all the other disappear, so the curve is guaranteed to start at point <strong>A</strong></li>
<li>Similarly, when the <span class="text_black"><strong>progress</strong></span> is <a href="index.html#" class="link_button" onclick="quad_curve_plot_f1();return false;">equal to 1</a> the weight function of control point <strong>C</strong> reaches 1 and all the other disappear, so the curve is guaranteed to <em>end</em> at point <strong>C</strong></li>
<li>When <span class="text_black"><strong>progress</strong></span> is <a href="index.html#" class="link_button" onclick="quad_curve_plot_f2();return false;">between</a> those two extrema the position of the points on the curve is affected by all 3 control points</li>
</ul>
<p>It&rsquo;s also worth pointing out that the &ldquo;speed&rdquo; of travel along the curve is no longer constant like it was for a linear segment. We can visualize how uniform steps of <span class="text_black"><strong>progress</strong></span> map to the curve points:</p>
<div class="drawer_container full_width ratio_50" id="cs_quad_curve_plot2"></div>
<div class="slider_black" id="cs_quad_curve_plot2_sl0"></div>
<p>For <a href="index.html#" class="link_button" onclick="quad_curve_plot2_f0();return false;">some configurations</a> when the slider is <a href="index.html#" class="link_button" onclick="quad_curve_plot2_f1();return false;">halfway</a> along the progress, the curve is definitely <em>not</em> halfway drawn. In some applications, e.g. when an object is expected to move along a curve with constant velocity, that discrepancy between the &ldquo;input&rdquo; progress and actual progress of distance along the curve may be very important, but for our visual use cases it won&rsquo;t matter.</p>
<p>Quadratic Bézier curves are unfortunately fairly limited. For instance, it&rsquo;s impossible to express any sort of loop with a plain curve like that. To get better control over the shape of the curve we need to somehow introduce additional control points that would give us finer tunability of the curve&rsquo;s form.</p>
<p>Looking at the equations and weighting functions it may be a bit hard to figure out how we could generalize the curve to introduce more points. Let&rsquo;s look the at that equation again:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>1</td><td>&times;</td><td class="equation_right">A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>2</td><td>&times;</td><td>B</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>1</td><td>&times;</td><td class="equation_right">C</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td>
    </td>
</tr>
</table>
</div>
<p>We can split the doubled <strong>B</strong> part and rearrange things a little to get:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td class="no_right_pad">(</td><td class="no_left_pad">A</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>B</td><td>&times;</td><td><div class="t"></div></td><td class="no_left_pad">)</td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td class="equation_lhs">
    </td>
    <td class="equation_center">
    </td>
    <td class="no_right_pad">(</td><td class="no_left_pad">B</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>C</td><td>&times;</td><td><div class="t"></div></td><td class="no_left_pad">)</td><td>&times;</td><td><div class="t"></div></td><td></td>
</tr>
</table>
</div>
<p>It may seem that we only made things worse, but in fact we simplified things greatly. Notice that the values in the parentheses are just linear interpolations between points <strong>A</strong> and <strong>B</strong> as well as <strong>B</strong> and <strong>C</strong>. We can call these new points <strong>AB</strong> and <strong>BC</strong>:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    AB
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>A</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>B</td><td>&times;</td><td><div class="t"></div></td>
</tr>
<tr>
    <td class="equation_lhs">
    BC
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>B</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>C</td><td>&times;</td><td><div class="t"></div></td>
</tr>
</table>
</div>
<p>And then the final point <strong>P</strong> is just a linear interpolation of the two:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>AB</td><td>&times;</td><td><div class="nt"></div></td><td>+</td><td>BC</td><td>&times;</td><td><div class="t"></div></td>
</tr>
</table>
</div>
<p>Let&rsquo;s look at what we&rsquo;ve derived using some visuals:</p>
<div class="drawer_container full_width ratio_50" id="cs_quad_curve_interpolation"></div>
<div class="slider_black" id="cs_quad_curve_interpolation_sl0"></div>
<p>We essentially interpolate points on the edges that we have, to create a new edge on which we then interpolate again to get the <span class="text_black"><strong>point</strong></span> on the <span class="text_red"><strong>curve</strong></span>. Now, if we introduce another control point we can just repeat this idea by doing repeated interpolations. Notice that at every step we have one fewer point and one fewer edge:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_curve_interpolation"></div>
<div class="slider_black" class="slider_black" id="cs_cubic_curve_interpolation_sl0"></div>
<p>This curve is known as a <em>cubic</em> Bézier curve. If we tally up all the interpolations we do we end up with the following compact form:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>1</td><td>&times;</td><td>A</td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>3</td><td>&times;</td><td>B</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="nt"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>3</td><td>&times;</td><td>C</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="nt"></div></td><td>+</td>
</tr>
<tr>
    <td></td><td></td>
    <td>1</td><td>&times;</td><td>D</td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td>&times;</td><td><div class="t"></div></td><td></td>
</tr>
</table>
</div>
<p>Observe how <span class="rounded_bg yellow"><strong>(1 − t)</strong></span> sections convert to <span class="rounded_bg yellow"><strong>t</strong></span> sections for the subsequent points. All those multiplications of triangular functions end up creating the following set of weights for the control points:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_curve_plot"></div>
<div class="slider_black" id="cs_cubic_curve_plot_sl0"></div>
<p>The ideas behind two dimensional cubic Bézier curves naturally extend to the third dimension – the curve can twist and turn as it goes through space:</p>
<div class="drawer_container ratio_100" id="cs_cubic_bezier_3d"></div>
<p>We&rsquo;re not just here to talk about curves, so let&rsquo;s try to see how we can extend Bézier curves into surfaces.</p>
<h1 id="bézier-patches">Bézier Patches<a href="index.html#bézier-patches" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>When we were creating a simple surface we were sliding a straight segment along some other two linear segments. We can expand this idea to slide a <span class="text_yellow"><strong>straight segment</strong></span> along two <span class="text_purple"><strong>cubic Bézier curves</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_cubic_linear_patch"></div>
<div class="slider_s" id="cs_cubic_linear_patch_sl0"></div>
<p>While the surface itself is now more varied on the <span class="text_purple"><strong>purple edges</strong></span>, it&rsquo;s hard to hide the straightness of the <span class="text_yellow"><strong>yellow segment</strong></span>. To make things more varied we could replace that segment with a single cubic Bézier curve that we would stretch as we go, but by building up on the previous ideas we can do something much more interesting.</p>
<p>Firstly, we&rsquo;ll introduce a set of <em>four</em> cubic Bézier curves in the 3D space. Then we can use those <span class="text_purple"><strong>four curves</strong></span> as rails on which <span class="text_black"><strong>four control points</strong></span> can slide. Those <span class="text_black"><strong>control points</strong></span> in turn define a  <span class="text_yellow"><strong>new Bézier curve</strong></span> which in turn traces the final surface as it travels through space:</p>
<div class="drawer_container ratio_100" id="cs_cubic_four_curves_surface"></div>
<div class="slider_black" id="cs_cubic_four_curves_surface_sl0"></div>
<p>Notice that the <span class="text_black"><strong>four black control points</strong></span> aren&rsquo;t directly controllable –  they change their positions as they slide on the <span class="text_purple"><strong>purple rails</strong></span> which in turn keeps changing the <span class="text_yellow"><strong>dragged Bézier curve</strong></span>. This process forms a cubic Bézier surface, or a cubic Bézier <em>patch</em>. That new surface is all together defined by 16 control points which can be arranged in a connected 4×4 grid:</p>
<div class="drawer_container ratio_100" id="cs_cubic_patch"></div>
<p>As we&rsquo;ve already seen, every point on that surface is first defined by evaluation across the set of <span class="text_blue"><strong>four Bézier curves</strong></span> followed by interpolation on the resulting <span class="text_yellow"><strong>new curve</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_cubic_four_curves_surface2"></div>
<div class="slider_t" id="cs_cubic_four_curves_surface2_sl0"></div>
<div class="slider_s" id="cs_cubic_four_curves_surface2_sl1"></div>
<p>Each point of the input square corresponds to some <span class="text_black"><strong>point</strong></span> on the surface. The surface distorts the straight lines on the input square into cubic Bézier curves in the 3D space:</p>
<div class="drawer_container ratio_100" id="cs_cubic_patch2"></div>
<div class="slider_s" id="cs_cubic_patch2_sl0"></div>
<div class="slider_t" id="cs_cubic_patch2_sl1"></div>
<p>The equation driving that surface is so massive that I&rsquo;ll just represent the <span class="equation_inline s"></span> <span class="equation_inline ns"></span> <span class="equation_inline t"></span> <span class="equation_inline nt"></span> parts using their triangular symbols:</p>
<div class="equation">
<table>
<tr>
    <td class="equation_lhs">
    P
    </td>
    <td class="equation_center">
     = 
    </td>
    <td>P<sub>11</sub></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>12</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>13</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>14</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>21</sub></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>22</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>23</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>24</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>31</sub></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>32</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>33</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>34</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="nt small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>41</sub></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>42</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>43</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="ns small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>+</td>
</tr>
<tr>
<td></td><td></td>
    <td>P<sub>44</sub></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="s small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td>&times;</td><td><div class="t small"></div></td><td></td>
</tr>
</table>
</div>
<p>The result of all of those 16 sets of triangular multiplications are 16 weighting functions that define how important the given control point is to the shape of the surface in the point&rsquo;s vicinity:</p>
<div class="drawer_container ratio_100" id="cs_linear_patch_hats2"></div>
<div class="slider_s" id="cs_linear_patch_hats2_sl0"></div>
<div class="slider_t" id="cs_linear_patch_hats2_sl1"></div>
<p>Notice the symmetry in all those functions – ultimately there are only three unique shapes here, the others are their reflections and rotations.</p>
<h1 id="beyond-cubic">Beyond Cubic<a href="index.html#beyond-cubic" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>While relatively flexible, simple cubic curves and surfaces have their limitations. For example, a <span class="text_red"><strong>cubic Bézier curve</strong></span> can have at most two &ldquo;bends&rdquo; – it&rsquo;s impossible to make it fit the <span style="color:#999"><strong>gray curve</strong></span>:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_fit"></div>
<p>One approach to solve this problem is to build more complicated Bézier curves by increasing the number of control points. Thankfully, our method of linearly interpolating the linear interpolations that we used to upgrade quadratic Bézier curves to cubic ones allows us to add arbitrary number of control points. In the demonstration below you can see how a Bézier curve with <em>eight</em> control points is built:</p>
<div class="drawer_container full_width ratio_50" id="cs_high_deg_bezier"></div>
<div id="cs_high_deg_bezier_sl0"></div>
<p>On every interpolation step we reduce the number of intermediate points by one and after the 7<sup>th</sup> step we&rsquo;re down to our final point that defines the path. With a single Bézier curve with that many control points we can finally try to fit the shape:</p>
<div class="drawer_container full_width ratio_50" id="cs_septic_fit"></div>
<p>Bézier curves with more control points provide better flexibility, but unfortunately they come with their own problems. Firstly, notice that to <a href="index.html#" class="link_button" onclick="septic_fit_f0();return false;">fit the shape</a> the control points of the <span class="text_red"><strong>curve</strong></span> have to be put quite far apart making them slightly less convenient to use.</p>
<p>Moreover, changes to any of the control points causes the <em>entire</em> curve to move. In the demonstration below I&rsquo;ve enlarged a small section in the beginning of a <span class="text_red"><strong>curve</strong></span>. When you move the <span class="text_black"><strong>selected</strong></span> 6<sup>th</sup> point, the section of the <span class="text_red"><strong>curve</strong></span> near the <em>2<sup>nd</sup></em> control point changes as well:</p>
<div class="drawer_container full_width ratio_50" id="cs_septic_zoom"></div>
<p>When we look at the plot of the weight that each point has as we <span class="text_black"><strong>progress</strong></span> through the curve we can notice that, to some extent, they all contribute almost the entire curve:</p>
<div class="drawer_container full_width ratio_50" id="cs_septic_curve_plot"></div>
<div class="slider_black" id="cs_septic_curve_plot_sl0"></div>
<p>Single Bézier curves with many control points lack the property of <em>local control</em>, making them not as useful for expressing more complicated shapes, so for better or for worse we have to rethink our approach to designing complicated shapes.</p>
<h1 id="splines">Splines<a href="index.html#splines" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Instead of using a single curve with many control points, we can use multiple curves with few control points. In the demonstration below I put three <span class="text_yellow"><strong>cubic</strong></span> <span class="text_red"><strong>Bézier</strong></span> <span class="text_blue"><strong>curves</strong></span> that we can arrange to create more complex shapes:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_spline"></div>
<p>While flexible, this setup is a bit cumbersome to use, as these three curves have gaps unless we <a href="index.html#" class="link_button" onclick="cubic_spline_f0();return false;">connect their end points</a>. We can automate this connection process by having the last control point of the previous curve always match the first point of the next curve:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_spline1"></div>
<p>This solves the problem of gaps but if we&rsquo;re aiming for nice, smooth shapes then we still have some sharp corners to account for. To remove the kinks we have to ensure that the <em>tangency</em> of neighboring curves is continuous as well.</p>
<p>I&rsquo;ve <a href="../gears/index.html#tangent--normal">discussed</a> tangency on this blog before, but, as a quick recap, a tangent is a local &ldquo;straight ahead&rdquo; direction. It can be easily found by sliding <span class="text_red"><strong>two beads</strong></span> on a <span style="color:#777"><strong>curve</strong></span>. As the <span class="text_red"><strong>beads</strong></span> get closer, the line spanned through their centers approaches the tangent direction:</p>
<div class="drawer_container full_width ratio_50" id="cs_tangent"></div>
<div class="slider_black" id="cs_tangent_sl0"></div>
<div class="slider_red" id="cs_tangent_sl1"></div>
<p>To ensure that the tangency of neighboring cubic Bézier curves is consistent the next <em>and</em> previous neighbors of the joining control point have to lie on the same straight line. Many design tools tie the control points of neighboring curves together giving a single control axis that maintains the tangency. That entire utility is usually known as a <em>pen</em> or <em>vector</em> tool:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_spline2"></div>
<p>The curves we&rsquo;ve built in this section are known as <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)"><em>splines</em></a> which are piecewise polynomial curves – they&rsquo;re constructed from different pieces, each one described by a polynomial function.</p>
<p>When it comes to designing complex surfaces, we can employ the same idea of using multiple cubic Bézier patches to form more complicated shapes. With the most basic setup those have the same continuity problems that individual curves had:</p>
<div class="drawer_container ratio_100" id="cs_two_cubic_patches"></div>
<p>Notice how much work it is to have the two surfaces without any gaps. Thankfully, just like we did for curves, the edge points of neighboring patches can be tied together to make the seam water tight.</p>
<p>When it comes to tangency, the concept of a <em>single</em> tangent direction doesn&rsquo;t make that much sense for surfaces – at a given point the surface &ldquo;goes&rdquo; in many directions. To account for that we define an entire tangent <em>plane</em>. Similarly to what we did for curves we can take <span class="text_red"><strong>three beads</strong></span> and <span style="color:#555"><strong>three straight wires</strong></span> attached to them and then slide those <span class="text_red"><strong>beads</strong></span> close to the <span class="text_black"><strong>point</strong></span> on the surface:</p>
<div class="drawer_container ratio_100" id="cs_surface_tangent_plane"></div>
<div class="slider_s" id="cs_surface_tangent_plane_sl0"></div>
<div class="slider_t" id="cs_surface_tangent_plane_sl1"></div>
<div id="cs_surface_tangent_plane_sl2"></div>
<p>As the <span class="text_red"><strong>beads</strong></span> come to the target <span class="text_black"><strong>point</strong></span> infinitely close the three wires define the <span style="color:#DC8686"><strong>tangent plane</strong></span>. That plane also has a perpendicular direction which we call a <em>normal</em> direction of the surface at that <span class="text_black"><strong>point</strong></span> – I&rsquo;ve marked that direction with a <span class="text_red"><strong>red arrow</strong></span>:</p>
<div class="drawer_container ratio_100" id="cs_surface_normal"></div>
<div class="slider_s" id="cs_surface_normal_sl0"></div>
<div class="slider_t" id="cs_surface_normal_sl1"></div>
<p>For two surfaces to be connected without a sharp edge we need the normals at the joining edge to be aligned in the same direction:</p>
<div class="drawer_container ratio_100" id="cs_two_cubic_patches_normals"></div>
<p>Note that even when the surfaces don&rsquo;t have any gaps it still requires a <a href="index.html#" class="link_button" onclick="two_cubic_patches_normals_f0();return false;">lot of adjustments</a> to keep them connected and free of sharp edges. But that&rsquo;s not even the end of the difficulties that joined patches create.</p>
<h1 id="curved-mirror-on-the-wall">Curved Mirror on The Wall<a href="index.html#curved-mirror-on-the-wall" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>It would be reasonable to think that removal of sharp edges is all it takes to create pretty surfaces, but when the surfaces are <em>reflective</em> we still have some work to do. In the demonstration below you can see a mirror-polished surface reflecting a <span class="text_red"><strong>red sphere</strong></span>. By dragging the slider you can bend that surface into an arc of a circle, the <span class="text_black"><strong>black curve</strong></span> below shows a cross section of the mirror&rsquo;s shape:</p>
<div class="drawer_container ratio_100" id="cs_cubic_patch_mirror"></div>
<div id="cs_cubic_patch_mirror_sl0"></div>
<p>Notice that as the mirror pulls away from the flat shape the reflection of the sphere gets narrower. To get an intuitive understanding of why this happens we have to look at this situation from the side. The <span class="text_black"><strong>black line</strong></span> represents the mirror and the <span class="text_red"><strong>red line</strong></span> shows a reflection of the sphere in that mirror:</p>
<div class="drawer_container ratio_50" id="cs_cubic_patch_mirror_normals"></div>
<div id="cs_cubic_patch_mirror_normals_sl0"></div>
<p>When the surface curves, its <span style="color:#999"><strong>normal directions</strong></span> spread out. In simple terms, a curved mirror “sees” more of its environment but since the mirror&rsquo;s area stays the same, the reflection of the sphere has to shrink to fit in.</p>
<p>When we bend the surface we&rsquo;re actually changing the <a href="https://en.wikipedia.org/wiki/Curvature"><em>curvature</em></a> of the profile of the surface. Roughly speaking, curvature defines how quickly a curve changes its direction.</p>
<p>In the demonstration below I&rsquo;ve marked curvy sections of the curve with different colors – the higher the curvature the more intense the color. Notice that this curve can bend in two different directions, so I&rsquo;m using <span style="color:#FF8E00"><strong>orange</strong></span> and <span style="color:#0053FF"><strong>blue</strong></span> to distinguish these cases. By dragging the <span class="text_black"><strong>slider</strong></span> you can witness how quickly the local direction of the curve, shown as a <span class="text_black"><strong>black arrow</strong></span>, changes in the areas of large curvature:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_curve_curvature"></div>
<div class="slider_black" id="cs_cubic_curve_curvature_sl0"></div>
<p>A <a href="index.html#" class="link_button" onclick="cubic_curve_curvature_f0();return false;">straight line</a> has no curvature and the arrow never turns, while a <a href="index.html#" class="link_button" onclick="cubic_curve_curvature_f1();return false;">tight turn</a> has a high curvature and the arrow turns very rapidly when passing through it. To show a more precise measure of a curvature we can use an <a href="https://en.wikipedia.org/wiki/Osculating_circle"><em>osculating circle</em></a> which conceptually is a circle that locally &ldquo;fits&rdquo; into the curve:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_curve_circle"></div>
<div class="slider_black"  id="cs_cubic_curve_circle_sl0"></div>
<p>Curvature <strong>κ</strong> is the inverse of the radius <strong>R</strong> of that circle:</p>
<div class="equation">
<span class="equation_frac"><span>&kappa;</span></span> = <span class="equation_frac"><span>1</span>
    <span class="equation_div_symbol">/</span>
    <span>R</span>
</span>
</div>
<p>That radius <strong>R</strong> is also known as the <em>radius of curvature</em>. Note that the inverse relation makes sense – a <em>small</em> curvature implies a <em>not</em> very curvy region which in turn implies <em>large</em> radius of curvature. A curvature of a curve is also often visualized using a <em>curvature comb</em>:</p>
<div class="drawer_container full_width ratio_50" id="cs_cubic_curve_comb"></div>
<p>Comb&rsquo;s teeth are protruding in the normal direction of the curve and the higher a tooth&rsquo;s length, the larger the curvature in that region.</p>
<p>Let’s look at <em>two</em> reflective surfaces next to each other. I made their backs have different colors so that it&rsquo;s easier to see where they join. The <span class="text_red"><strong>top slider</strong></span> controls the position of the sphere and the <span class="text_black"><strong>bottom one</strong></span> controls how closely the curvatures of the two surfaces match:</p>
<div class="drawer_container ratio_100" id="cs_two_cubic_patches_mirror"></div>
<div class="slider_red" id="cs_two_cubic_patches_mirror_sl0"></div>
<div class="slider_black" id="cs_two_cubic_patches_mirror_sl1"></div>
<p>Notice that the connection doesn&rsquo;t have any sharp edges. However, for different values of the <span class="text_black"><strong>curvature match</strong></span> the reflection of the sphere at the connection can look <a href="index.html#" class="link_button" onclick="two_cubic_patches_mirror_f0();return false;">weirdly deformed</a> into an UFO‑like shape, or it can be <a href="index.html#" class="link_button" onclick="two_cubic_patches_mirror_f1();return false;">quite smooth</a>. If we analyze the situation from a side profile with a curvature comb visible we can get a clearer picture of what&rsquo;s going on:</p>
<div class="drawer_container ratio_50" id="cs_two_cubic_patches_side"></div>
<div class="slider_red" id="cs_two_cubic_patches_side_sl0"></div>
<div class="slider_black" id="cs_two_cubic_patches_side_sl1"></div>
<p>This view explains why in <a href="index.html#" class="link_button" onclick="two_cubic_patches_side_f0();return false;">some cases</a> the transition between the arched and the flat part of the surface has a visible jump in the sphere&rsquo;s reflection – there is a <em>sudden</em> transition between the area where the curvature is zero and the reflected image is not squeezed at all, and the area of non-zero curvature where the image is squeezed a lot. When we <a href="index.html#" class="link_button" onclick="two_cubic_patches_side_f1();return false;">fix that sudden jump</a>, the reflected image becomes <em>gradually</em> squeezed as it enters the curved part.</p>
<p>When curvatures between connected surfaces don&rsquo;t match, the reflections may look very weird. <em>Curvature continuity</em> is critical for achieving <a href="https://en.wikipedia.org/wiki/Class_A_surface">high quality</a> reflective surfaces which are very commonly used e.g. on cars.</p>
<p>Even when surfaces are very far from being mirror-polished a rapid change in curvature may be observable:</p>
<div class="drawer_container ratio_100" id="cs_two_cubic_patches_lambert"></div>
<div class="slider_black" id="cs_two_cubic_patches_lambert_sl0"></div>
<p>Notice that in <a href="index.html#" class="link_button" onclick="two_cubic_patches_lambert_f0();return false;">some orientations</a> you can see a fairly sharp falloff in the shading on the surface. That transition gets much smoother if we <a href="index.html#" class="link_button" onclick="two_cubic_patches_lambert_f1();return false;">make the curvatures vary more smoothly</a>.</p>
<p>Even though we were looking at light reflected off surfaces, we’ve actually been talking about the curvature of the <em>curve</em> defining the profile of those surfaces. The notion of the curvature of a surface itself is a bit more complex, but in many cases it involves analyzing curvatures of curves living on that surface. Let&rsquo;s try to look for some of those curves.</p>
<p>For every point on a surface we can take a <span class="text_red"><strong>normal direction</strong></span> and use it as pivot on which a <span style="color:#DC8686"><strong>new plane</strong></span> can rotate:</p>
<div class="drawer_container ratio_100" id="cs_cubic_patch_curvature_cut"></div>
<div class="slider_s" id="cs_cubic_patch_curvature_cut_sl0"></div>
<div class="slider_t" id="cs_cubic_patch_curvature_cut_sl1"></div>
<div id="cs_cubic_patch_curvature_cut_sl2"></div>
<p>Notice that this <span style="color:#DC8686"><strong>plane</strong></span> slices the surface creating a curve at the cross section. We can then find the curvature of that curve at that <span class="text_black"><strong>point</strong></span>  and show the osculating circle, or at least a part of it:</p>
<div class="drawer_container ratio_100" id="cs_cubic_patch_curvature_circle"></div>
<div class="slider_s" id="cs_cubic_patch_curvature_circle_sl0"></div>
<div class="slider_t" id="cs_cubic_patch_curvature_circle_sl1"></div>
<div id="cs_cubic_patch_curvature_circle_sl2"></div>
<p>These curvatures are known as <em>normal curvatures</em>. Notice that at a given <span class="text_black"><strong>point</strong></span> a surface will have many curvatures, one for every direction of slicing. However, at every point there is a direction for which that curvature takes the <span class="text_green"><strong>maximum</strong></span> value, and a direction for which the curvature takes the <span class="text_red"><strong>minimum</strong></span> value. Note that the minimum value can be the <em>most negative</em>. Those two maxima are known as <a href="https://en.wikipedia.org/wiki/Principal_curvature"><em>principal curvatures</em></a>. I&rsquo;ve shown them in the demonstration below:</p>
<div class="drawer_container ratio_100" id="cs_cubic_patch_curvature_circle_principal"></div>
<div class="slider_s" id="cs_cubic_patch_curvature_circle_principal_sl0"></div>
<div class="slider_t" id="cs_cubic_patch_curvature_circle_principal_sl1"></div>
<p>For some <a href="index.html#" class="link_button" onclick="cubic_patch_curvature_circle_principal_f0();return false;">cylindrical shapes</a>, one of the curvatures will always be 0, but for <a href="index.html#" class="link_button" onclick="cubic_patch_curvature_circle_principal_f1();return false;">saddle-like surfaces</a> one will be positive and one negative. Moreover, the directions of two principal curvatures are always perpendicular to each other, but the reason for that is a bit <a href="https://math.stackexchange.com/questions/71854/is-there-a-geometric-explanation-for-why-principal-curvature-directions-are-orth">complicated</a>. The product of the two principal curvatures is known as <a href="https://en.wikipedia.org/wiki/Gaussian_curvature"><em>Gaussian curvature</em></a>.</p>
<p>While the curvature discontinuity was easy to see on reflective surfaces, it’s quite hard to notice on regular 2D curves. However, in some cases we can actually feel it.</p>
<p>Trains and subway carts ride on railroads that can&rsquo;t go on straight forever – at some point they have to change direction. One could naively think that a turn of a train&rsquo;s track consists of an <span style="color:#C68D8F"><strong>arc of a circle</strong></span> joining two <span style="color:#7BA7CD"><strong>straight segments</strong></span>. In the demonstration below I put a <span class="text_yellow"><strong>little train</strong></span> riding on that track. You can control the time using the slider:</p>
<div class="drawer_container full_width ratio_50" id="cs_train_force0"></div>
<div id="cs_train_force0_sl0"></div>
<p>The <span class="text_red"><strong>red arrow</strong></span> shows a <a href="https://en.wikipedia.org/wiki/Centripetal_force"><em>centripetal force</em></a> that makes the train and thus its passengers change direction. That <span class="text_red"><strong>force</strong></span> <strong>F</strong> depends on the mass <strong>m</strong> of the object, a square of its velocity <strong>V</strong>, and the radius of curvature <strong>R</strong> of the traveled path:</p>
<div class="equation">
<span class="equation_frac"><span>F</span></span> = <span class="equation_frac"><span>m &times; V<sup>2</sup></span>
    <span class="equation_div_symbol">/</span>
    <span>R</span>
</span>
</div>
<p>On the straight part the radius of curvature is infinite so the force is 0, but when the train enters the circular part of our simple track the centripetal force suddenly appears leading to a very unpleasant jerk. That jerk is caused by the track&rsquo;s curvature suddenly changing from a zero to a non-zero value. Real train tracks use <a href="https://en.wikipedia.org/wiki/Track_transition_curve"><em>transition curves</em></a> that smoothly vary the curvature between the straight and circular parts to avoid a sudden increase in forces which makes the ride much smoother.</p>
<p>Let&rsquo;s sum up the different classes of continuities that we&rsquo;ve discussed so far:</p>
<div class="ts_space_list_wrap">
<div class="ts_space_list">
<div class="ts_space_list_item ts_space_list_0"><span class="ts_space">G0</span> position continuity</div><br>
<div class="ts_space_list_item ts_space_list_0"><span class="ts_space">G1</span> tangency continuity</div><br>
<div class="ts_space_list_item ts_space_list_2"><span class="ts_space">G2</span> curvature continuity</div><br>
</div>
</div>
<p>We can visualize them on two Bézier curves with curvature combs visible. Notice that as you enable higher degrees of continuity the movement of some of the control points becomes restricted:</p>
<div class="drawer_container full_width ratio_50" id="cs_continuities"></div>
<div id="cs_continuities_seg0"></div>
<p>While different tricks and affordances can be employed to maintain these continuities, we should look for a better way to design complex curves and surfaces – a method that has all these continuities built-in.</p>
<h1 id="building-the-basis">Building the Basis<a href="index.html#building-the-basis" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Let&rsquo;s take a step back and look at the weights of the single Bézier curve with eight control points that we&rsquo;ve already dismissed:</p>
<div class="drawer_container full_width ratio_50" id="cs_septic_curve_plot2"></div>
<div class="slider_black" id="cs_septic_curve_plot2_sl0"></div>
<p>The problem with that approach was that the weight of each control point had a very far reaching range – it spans the entire progress of the curve. Let&rsquo;s try to minimize how far reaching the impact of each point is by replacing it with simple triangular functions:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_triangle_plot"></div>
<div class="slider_black" id="cs_spline_triangle_plot_sl0"></div>
<p>The weight of a control point is now non-zero only in a small range of the entire progress of the curve – each point has a minimized reach. Unfortunately, the resulting curve is not very impressive. While it doesn&rsquo;t have any gaps, it forms just a plain polyline. The beauty of this approach, however, is that we can try using <em>better</em> base functions with limited range.</p>
<p>One could be tempted to use an arbitrary shape for the individual weighting functions, for example, some smoother parabolas:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_funky_plot"></div>
<div class="slider_black" id="cs_spline_funky_plot_sl0"></div>
<p>The results are completely janky. We&rsquo;ve not only created some weird arcs, but also their shape and &ldquo;sidedness&rdquo; depends on where on screen the control points are.</p>
<p>To understand why this happens we have to look at the <em>sum</em> of all the weighting functions over the entire range, I&rsquo;ve visualized it using a thick <span class="text_yellow"><strong>yellow line</strong></span> on top of the plot:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_funky_plot2"></div>
<div class="slider_black" id="cs_spline_funky_plot2_sl0"></div>
<p>Notice the resulting curve behaves weirdly in the regions where the weighting functions add up to more than 1.0, I&rsquo;ve depicted that 1.0 margin with a <span class="dashed">dashed</span> line. In those faulty ranges we no longer take a proper weighted average of some points, causing the broken behavior.</p>
<p>In fact, all the curves we&rsquo;ve discussed so far had the property that all their weighting functions added up to 1 within the defined range forming a so called <em>partition of unity</em>. That concept is critical for the design of the weighting functions, as it makes the resulting curve behave as expected when all the control points are moved around as a group.</p>
<p>We could try to normalize the janky parabolas to make them nice, but in practice we&rsquo;ll use so called <a href="https://en.wikipedia.org/wiki/B-spline"><em>B‑spline</em></a> functions that are very well behaved. The most primitive B‑spline function of order 1 has a value of 1.0 in a small range and 0.0 everywhere else as seen below. Higher orders of B‑spline functions are generated from two lower order functions, with a simple procedure that you can witness by dragging the slider:</p>
<div class="drawer_container ratio_50" id="cs_bspline_creation"></div>
<div class="long_slider" id="cs_bspline_creation_sl0"></div>
<p>In fact, our triangular function is a B‑spline function of <a href="index.html#" class="link_button" onclick="bspline_creation_f0();return false;">order 2</a>. The <a href="index.html#" class="link_button" onclick="bspline_creation_f1();return false;">next order</a> forms a <em>quadratic</em> B‑spline. Here&rsquo;s a curve built using quadratic B‑splines as base functions:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_quadratic_plot"></div>
<div class="slider_black" id="cs_spline_quadratic_plot_sl0"></div>
<p>The curve no longer has any unpredictable behavior and doesn&rsquo;t have any sharp corners. In fact it has both position (G0), and tangency (G1) continuity. The fourth order B‑spline, known as a <em>cubic</em> B‑spline, is even better – its curvature is also continuous making the entire curve G2 continuous:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_cubic_plot"></div>
<div class="slider_black" id="cs_spline_cubic_plot_sl0"></div>
<p>The weighting functions of B‑splines have limited range so every control point only modifies the curve locally which solves the problems we&rsquo;ve seen with complicated Bézier curves. However, you&rsquo;ve probably noticed that for both quadratic and cubic B‑splines the curve no longer reaches the first and last control points. In some cases it&rsquo;s not a problem, e.g. when the control points form a closed loop:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_cubic_loop_plot"></div>
<div class="slider_black" id="cs_spline_cubic_loop_plot_sl0"></div>
<p>To solve the problem for open curves we can&rsquo;t just allow the <span class="text_black"><strong>progress</strong></span> to go out of range since the weighting functions don&rsquo;t add up to 1.0 there and we&rsquo;ve already seen the problems that would cause. Instead, we have to modify the functions <em>inside</em> that valid range.</p>
<p>Firstly, notice that the functions we&rsquo;ve built were designed over a repeating, <em>uniform</em> interval that I&rsquo;ve been marking using small triangles <span class="knot"></span> at the bottom. Those triangles represent so called <em>knots</em> on which the individual weighting functions are built.</p>
<p>However, nothing prevents us from adjusting those intervals as we please, making their distribution <em>non-uniform</em>. In the demonstration below you can witness how the B‑spline rules create different functions when the <span class="text_ocean"><strong>distance between knots</strong></span> changes:</p>
<div class="drawer_container ratio_50" id="cs_bspline_creation2"></div>
<div class="long_slider" id="cs_bspline_creation2_sl0"></div>
<div class="slider_ocean" id="cs_bspline_creation2_sl1"></div>
<p>We no longer can simply shift the base function to the right and instead we have to build the individual functions all the way up from order 1 because each function may be defined over different interval of knots. With those rules in place, you can witness what happens to the end points of the curve as we adjust the <span class="text_ocean"><strong>position of the knots</strong></span>:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_cubic_knots_plot"></div>
<div class="slider_black" id="cs_spline_cubic_knots_plot_sl0"></div>
<div class="slider_ocean" id="cs_spline_cubic_knots_plot_sl1"></div>
<p>When the first four and last four knots overlap, a cubic B‑spline curve extends all the way to the boundary control points as desired. Additionally, the position of all the other knots can be adjusted too. In the demonstration below you can see what happens to the curve as we <span class="text_ocean"><strong>perturb</strong></span> the position of the <em>interior</em> knots as well:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_cubic_knots_plot2"></div>
<div class="slider_black" id="cs_spline_cubic_knots_plot2_sl0"></div>
<div class="slider_ocean" id="cs_spline_cubic_knots_plot2_sl1"></div>
<p>By moving three knots of a cubic B‑spline curve into a single location, we can achieve a sharp corner reigned by just a single control point. With uniformly distributed knots we&rsquo;d need to overlap <em>three</em> consecutive control points to get a sharp corner.</p>
<p>The curves we&rsquo;ve been playing with are known as a <em>non-uniform</em> B‑splines. However, the world of B‑splines has one more trick up its sleeve.</p>
<h1 id="b8209spline-extravaganza">B‑spline Extravaganza<a href="index.html#b8209spline-extravaganza" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>So far each of the weighting functions was equally important, but we can easily break that assumption by making some functions more important than others by changing their <em>relative</em> weights. For example, witness what happens to the curve as we modify the <span class="text_red"><strong>weight</strong></span> of the 4<sup>th</sup> control point that I&rsquo;ve marked with a letter <strong>D</strong>:</p>
<div class="drawer_container full_width ratio_50" id="cs_spline_cubic_weight_plot"></div>
<div class="slider_black" id="cs_spline_cubic_weight_plot_sl0"></div>
<div class="slider_red" id="cs_spline_cubic_weight_plot_sl1"></div>
<p>As we change the weight of that function the shapes of all the others are adjusted as well. This ensures that all the weighting functions add up to 1 over the entire valid range which maintains the partition of unity. By combining the non-uniform knot distribution with arbitrary weights we create non-uniform <em>rational</em> B‑splines, also known as <a href="https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline"><em>NURBS</em></a>. Notice that the weight of an individual function actually affects the <em>ratio</em> of weights, thus the <em>rational</em> name.</p>
<p>Interestingly enough, only rational B‑splines can represent an arc of a circle <em>exactly</em>. Plain B‑spline and Bézier curves can only approximate them.</p>
<p>The ideas behind the B‑spline curves naturally extend to surfaces as well. For example, here&rsquo;s the simplest uniform and non-rational B‑spline surface defined by a mesh of 4×4 control points:</p>
<div class="drawer_container ratio_100" id="cs_bspline_surface"></div>
<p>We can also build more complicated shapes by creating bigger rectangular grids of control points. When we tweak the position of the knots, we can make the surface go all the way to the edges of the control mesh:</p>
<div class="drawer_container ratio_100" id="cs_bspline_surface2"></div>
<p>While I&rsquo;m not going to demonstrate it here, one can also adjust the weights of individual weighting functions which fully exploits all the features that NURBS surfaces offer.</p>
<p>NURBS curves and surfaces are very powerful and they have a lot of flexibility, but they still have their limitations when it comes to modeling shapes. Firstly, it&rsquo;s quite difficult to cut holes in NURBS surfaces. One approach is to simply ignore some parts of the input square. In the demonstration below you can control the radius of the <span class="text_red"><strong>red circle</strong></span> that defines the region where we&rsquo;re <em>not</em> drawing the surface:</p>
<div class="drawer_container ratio_100" id="cs_nurbs_hole"></div>
<div class="slider_s" id="cs_nurbs_hole_sl0"></div>
<div class="slider_t" id="cs_nurbs_hole_sl1"></div>
<div class="slider_red" id="cs_nurbs_hole_sl2"></div>
<p>This operation is a bit cumbersome because achieving the desired shape of the hole on the surface requires tweaking the hole&rsquo;s shape on the input square so that it looks right <em>after</em> it&rsquo;s deformed by the surface.</p>
<p>You may have also noticed that all the meshes of control points we&rsquo;ve been dealing with were rectangular in nature. This heavily limits the types of surfaces we can create. For example, it&rsquo;s impossible to express a surface like the one below using a single B‑spline surface without having to somehow manually stitch it at the edges:</p>
<div class="drawer_container ratio_100" id="cs_subdiv2"></div>
<p>However, the entire point of using B‑spline curves and surfaces was to ensure automatic continuity and smoothness in the first place. Let&rsquo;s go back to the drawing board for the last time to devise a scheme that will help to solve all these problems.</p>
<h1 id="cutting-corners">Cutting Corners<a href="index.html#cutting-corners" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Instead of an actual drawing board let&rsquo;s start with a clean sheet of paper instead. Those usually come in rectangular shapes, but if we wanted a piece of paper to have a nice rounded corner we&rsquo;d have to do some work. One of the easiest way to do it is to repeatedly <span class="text_red"><strong>cut off</strong></span> the sharp corners:</p>
<div class="drawer_container ratio_70" id="cs_paper"></div>
<div class="slider_red" id="cs_paper_sl0"></div>
<p>After just three iterations the corner is quite round already. We can use this corner cutting idea to chip away at the control polygon of a curve as well. In the demonstration below you can control <span class="text_black"><strong>how many times</strong></span> we did the corner cutting procedure and the <span class="text_ocean"><strong>relative distance</strong></span> at which the cut happens:</p>
<div class="drawer_container full_width ratio_50" id="cs_chaikin"></div>
<div class="slider_black" id="cs_chaikin_sl0"></div>
<div class="slider_ocean" id="cs_chaikin_sl1"></div>
<p>If we cut the corners <a href="index.html#" class="link_button" onclick="chaikin_f0();return false;">too little</a> or <a href="index.html#" class="link_button" onclick="chaikin_f1();return false;">too much</a> the final curve will still look quite jaggy, but for <a href="index.html#" class="link_button" onclick="chaikin_f2();return false;">intermediate values</a> the resulting polyline starts to look very smooth – even the sharpest corners are chiseled down after a few iterations. This concept of corner cutting was originally devised by George Chaikin and the resulting curves are known as <em>subdivision curves</em>.</p>
<p>A particularly interesting curve is generated when the cut <a href="index.html#" class="link_button" onclick="chaikin_f3();return false;">happens</a> 1/4 of the way into the straight segments. As it was later discovered, that scheme actually converges to a <span class="text_red"><strong>curve</strong></span> that is equivalent to <span class="text_gray"><strong>quadratic B‑spline curve</strong></span> defined by the same initial control points:</p>
<div class="drawer_container full_width ratio_50" id="cs_chaikin_quadratic_bspline"></div>
<div class="slider_black" id="cs_chaikin_quadratic_bspline_sl0"></div>
<p>After just a few steps, the <span class="text_red"><strong>subdivision curve</strong></span> matches the <span class="text_gray"><strong>B‑spline curve</strong></span> in the background. This is a fantastic news, as it gives us yet another way to think about simple quadratic B‑spline curves – they&rsquo;re obtained by repeatedly cutting off corners of their control polygon.</p>
<p>The cutting scheme we&rsquo;ve used so far placed two new points on an existing edge, but that&rsquo;s not the only choice we have. For instance, we can place a <span class="text_yellow"><strong>new point</strong></span> on an existing edge <em>and</em> place another <span class="text_ocean"><strong>new point</strong></span> as a refinement of the existing vertex:</p>
<div class="drawer_container full_width ratio_50" id="cs_chaikin_cubic"></div>
<div class="slider_black" id="cs_chaikin_cubic_sl0"></div>
<div class="slider_ocean" id="cs_chaikin_cubic_sl1"></div>
<p>In this scheme the new edge point <span class="text_yellow"><strong>E<sub>new</sub></strong></span> lands right in the center of the edge, and the new vertex point <span class="text_ocean"><strong>V<sub>new</sub></strong></span> is a weighted average of the original vertex <strong>V</strong> and its previous and next neighbors <strong>V<sub>prev</sub></strong> and <strong>V<sub>next</sub></strong>. We can express that dependence using equations:</p>
<div class="equation">
<div><span class="text_ocean">V<sub>new</sub></span> = <span id="chw0"></span> &times; V<sub>prev</sub> + <span id="chw1"></span> &times; V + <span id="chw2"></span> &times; V<sub>next</sub></div>
<div><span class="text_yellow">E<sub>new</sub></span> = 0.5 &times; V<sub>prev</sub> + 0.5 &times; V<sub>next</sub></div>
</div>
<p>In some sense we&rsquo;re still cutting corners, but our method is a bit more sophisticated now. Once again, there exists a <a href="index.html#" class="link_button" onclick="cubic_chaikin_weights();return false;">set of weights</a> that&rsquo;s particularly important. The <span class="text_red"><strong>curve</strong></span> it generates in limit is a <span class="text_gray"><strong>cubic B‑spline curve</strong></span>:</p>
<div class="drawer_container full_width ratio_50" id="cs_chaikin_cubic_bspline"></div>
<div class="slider_black" id="cs_chaikin_cubic_bspline_sl0"></div>
<p>However, the beauty of subdivision curves doesn&rsquo;t end here. Firstly, we can modify the subdivision rules for the &ldquo;tail&rdquo; control points so that their new vertex points don&rsquo;t move at all – this makes the curve stick to its end points. Moreover, observe that we&rsquo;re making the new vertex position be a weighted average of the positions of the old vertex and its two neighbors, but we can easily extend that scheme to include <em>all</em> its neighbors. This allows us to handle branches and loops very easily:</p>
<div class="drawer_container full_width ratio_50" id="cs_curve_subdiv_topo"></div>
<div class="slider_black" id="cs_curve_subdiv_topo_sl0"></div>
<p>In the vicinity of those branchy points the curve is no longer a B‑spline curve, as those can&rsquo;t fork, but in the &ldquo;regular&rdquo; areas we still use the same subdivision rules that gave us the well-behaved cubic B‑splines functions. The subdivision curves <em>extend</em> the power of B‑splines curves into more arbitrary connectivity. The real magic starts when we employ subdivision rules for surfaces.</p>
<h1 id="subdivision-surfaces">Subdivision Surfaces<a href="index.html#subdivision-surfaces" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Inspired by Chaikin&rsquo;s original work for corner cutting in a quadratic B‑spline, <a href="https://en.wikipedia.org/wiki/Edwin_Catmull">Ed Catmull</a> and <a href="https://en.wikipedia.org/wiki/James_H._Clark">James Clark</a> have <a href="https://people.eecs.berkeley.edu/~sequin/CS284/PAPERS/CatmullClark_SDSurf.pdf">extended</a> these ideas to surfaces by creating <a href="https://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface">Catmull–Clark subdivision surfaces</a>. First, let&rsquo;s see them in action starting with a simple mesh of 4×4 vertices and 9 quadrilateral faces:</p>
<div class="drawer_container ratio_100" id="cs_subdiv_base_patch"></div>
<div id="cs_subdiv_base_patch_sl0"></div>
<p>After a few iterations the surface looks awfully familiar to the simplest cubic B‑spline patch we&rsquo;ve seen before. In fact, after infinitely many subdivisions that surface <em>does</em> turn into a cubic B‑spline surface.</p>
<p>The brilliance of Catmull and Clark was to come up with a subdivision scheme of a simple grid that in limit approaches the well defined B‑spline surfaces. Let&rsquo;s try to understand the gist of their method.</p>
<p>Starting with a single cubic B‑spline patch defined by a 4x4 control grid, they wanted to find an equivalent 5×5 control grid that would define <em>the same</em> surface. In other words, given the 16 control points <span class="control_point"></span> defining the <span style="color:#aaa"><strong>gray surface</strong></span>, we&rsquo;re looking for positions of the 25 <span class="text_red"><strong>new</strong></span> <span class="text_blue"><strong>control</strong></span> <span class="text_yellow"><strong>points</strong></span> that would define a surface with the same shape:</p>
<div class="drawer_container ratio_100" id="cs_subdiv_base"></div>
<p>The arithmetical procedures needed to be done aren&rsquo;t particularly important here, but ultimately the new control points can be classified into three distinct groups that end up corresponding to original <span class="text_red"><strong>faces</strong></span>, <span class="text_blue"><strong>edges</strong></span>, and <span class="text_yellow"><strong>vertices</strong></span>. Their exact creation rules are as follows:</p>
<div id="cc_list">
<ul>
<li><span><span class="text_red"><strong>new face points</strong></span> – average of the <span class="text_black"><strong>vertices</strong></span> forming the face</span></li>
<li><span><span class="text_blue"><strong>new edge points</strong></span> – average of the two <span class="text_red"><strong>new face points</strong></span> from neighboring faces and two <span class="text_black"><strong>existing end points</strong></span></span></li>
<li><span><span class="text_yellow"><strong>new vertex points</strong></span> – weighted average of: the <span class="text_black"><strong>existing vertex</strong></span>, midpoints of all the edges touching that vertex, and all the newly created <span class="text_red"><strong>face points</strong></span> from faces touching that <span class="text_black"><strong>existing vertex</strong></span></span></li>
</ul>
</div>
<p>On those new points new faces are created and we once again have a set of vertices and faces, but this time they&rsquo;re more refined. If we repeat that scheme over and over again the created faces of the control mesh will actually create a cubic B‑spline surface that the original control points defined:</p>
<div class="drawer_container ratio_100" id="cs_subdiv_base_patch2"></div>
<div id="cs_subdiv_base_patch2_sl0"></div>
<p>The crucial invention here is that nothing about the rules for creating the new subdivided control mesh relied on how the mesh itself is connected! If you recall, NURBS surfaces were limited to rectangular grids. Catmull-Clark subdivision scheme also works when the vertices of the initial mesh have different number of neighbors – in the mesh below each vertex has 3, 4, or 5 neighbors:</p>
<div class="drawer_container ratio_100" id="cs_subdiv0"></div>
<div id="cs_subdiv0_sl0"></div>
<p>Moreover, the initial faces also don&rsquo;t necessarily have to be four-sided, the subdivision rules also work for meshes whose faces are triangles or more complicated polygons:</p>
<div class="drawer_container ratio_100" id="cs_subdiv1"></div>
<div id="cs_subdiv1_sl0"></div>
<p>To express holes in a subdivision surface all we need to do is to <em>not</em> create faces in some regions of its defining mesh, like in this mask from the very first demonstration in this article:</p>
<div class="drawer_container ratio_100" id="cs_subdiv_hero2"></div>
<div id="cs_subdiv_hero2_sl0"></div>
<p>This example also has modified the subdivision rules on the edges to use cubic Chaikin subdivision rules. This ensures that the surface doesn&rsquo;t recede from the edges of the initial control mesh like we&rsquo;ve seen happen for a simple subdivided patch.</p>
<p>Subdivision surfaces make it very convenient to describe perfectly smooth surfaces using relatively simple meshes. To achieve sharper edges one can either move the points closer together, or use <a href="https://graphics.pixar.com/library/Geri/paper.pdf">extensions</a> of Catmull-Clark subdivision scheme that allow specifying edge sharpness.</p>
<h1 id="further-watching-and-reading">Further Watching and Reading<a href="index.html#further-watching-and-reading" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p><a href="https://pomax.github.io/bezierinfo/">A Primer on Bézier Curves</a> by Mike Kamermans is probably the best resource on the web dedicated to Bézier curves. Over the course of the extremely detailed article the author goes over a myriad of topics related to the curves, some <a href="https://pomax.github.io/bezierinfo/#matrix">very theoretical</a> and some <a href="https://pomax.github.io/bezierinfo/#arclengthapprox">very pragmatic</a>. The site truly is one of the internet&rsquo;s gems.</p>
<p>For a more advanced set of videos on topics related to curves and surfaces I recommend Keenan Crane&rsquo;s series on <a href="https://www.youtube.com/playlist?list=PL9_jI1bdZmz0hIrNCMQW1YmZysAiIYSSS">Discrete Differential Geometry</a>. Keenan is a <a href="https://www.cs.cmu.edu/~kmcrane/">professor</a> at Carnegie Mellon University and over the course of his lectures he does an excellent job of explaining the concepts with well made visual cues, while avoiding bogging the viewer down with <em>too</em> much formalism.</p>
<p>Finally, <a href="http://www.farinhansford.com/books/cagd/">Curves and Surfaces for CAGD</a> by Gerald Farin is a very good textbook on all the topics I&rsquo;ve discussed here any many more. The author does a much deeper dive into the underlying mathematics and the formulas are accompanied by well written explanations.</p>
<h1 id="final-words">Final Words<a href="index.html#final-words" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Ed Catmull later co-founded Pixar, and ever since the short film <a href="https://en.wikipedia.org/wiki/Geri%27s_Game">Geri&rsquo;s Game</a>, subdivision surfaces have been used in all of Pixar&rsquo;s movies. Catmull and Clark&rsquo;s invention made it easier for great storytellers to express themselves through computer graphics.</p>
<p>I find it fascinating that simple rules of repeated linear interpolations of straight segments end up creating delightful Bézier curves. Every letter you read on this website was crafted using Bézier curves, the primary building blocks of fonts.</p>
<p>Designers who shape exteriors of everyday objects or tweak the shapes used in 2D graphics focus on the visual form of their creations, but their creative freedom is unlocked by carefully composed mathematical formulas that power various design tools. I think it&rsquo;s charming that simple and unassuming equations end up creating beautiful curves and surfaces.</p>

    </div>
</div>
      </div>
    </div>
    <div id="footer">
        
<div class="article_footer">
If you enjoy these articles, consider supporting on <a href="https://www.patreon.com/ciechanowski">Patreon</a>.
</div>
Copyright &copy; 2024 Bartosz Ciechanowski
    </div>
  </div>
</body>

</html>