<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="theme-color" content="#2052BB">
<meta name="author" content="Bartosz Ciechanowski">
<meta name="format-detection" content="telephone=no">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-25335284-3"></script>


<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-25335284-3');
</script>
  <meta property="og:title" content="Alpha Compositing – Bartosz Ciechanowski" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ciechanow.ski/alpha-compositing/" />
<meta property="og:description" content="Interactive article explaining alpha compositing concepts." />
<meta property="og:locale" content="en_US">
    <meta name="keywords" content="alpha,compositing,porter,duff,premultiplied,blending,source,over">
  <link href="../css/base.css?2fdf9770" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Lato:700&display=swap" rel="stylesheet" type="text/css" async>
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,500&display=swap" rel="stylesheet" async>
  <title>Alpha Compositing – Bartosz Ciechanowski</title>
  <link rel="icon" href="../favicon.ico">
  <link href="../css/alpha_compositing.css" rel="stylesheet" type="text/css" />
  <script defer src="../js/base.js?ec479c57"></script>
  <script defer src="../js/alpha_compositing.js"></script>
</head>

<body>
  <div id="main_container">
    <div id="body">
      <div id="banner">
    <div id="banner_wrapper">
        <div id="banner_content">
            <div id="site_title">
                <a href="../index.html">Bartosz Ciechanowski</a>
            </div>
            <div id="navigation">
                <a href="../index.html">Blog</a>
                <a href="../archives.html">Archives</a>
            </div>
            <div id="social">
                <a class="patreon" href="https://www.patreon.com/ciechanowski" title="Patreon"><div class="patreonLogo">Patreon</div></a>
                <a class="twitter" href="https://twitter.com/bciechanowski" title="X / Twitter"><div class="twitterLogo">X / Twitter</div></a>
                <a class="instagram" href="https://www.instagram.com/bartoszciechanowski/" title="Instagram"><div class="igLogo">Instagram</div></a>
                <a class="email" href="mailto:bartosz@ciechanow.ski" title="e-mail"><div class="emailLogo">e-mail</div></a>
                <a class="rss" href="../atom.xml" title="RSS"><div class="rssLogo">RSS</div></a>
            </div>
        </div>
    </div>
</div>

      <div id="content">
        
<div class="article">
    <div class="post_date">July 24, 2019</div>
    <h1 class="post_title"><a href="index.html">Alpha Compositing</a></h1>
    <div class="padding_wrapper"><p>Transparency may not seem particularly exciting. The GIF image format which allowed some pixels to show through the background was published over 30 years ago. Almost every graphic design application released in the last two decades has supported the creation of semi-transparent content. The novelty of these concepts is long gone.</p>
<p>With this article I&rsquo;m hoping to show you that transparency in digital imaging is actually much more interesting than it seems – there is a lot of invisible depth and beauty in something that we often take for granted.</p>
<h1 id="opacity">Opacity<a href="index.html#opacity" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>If you ever had a chance to look through rose-tinted glasses you may have experienced something akin to the simulation below. Try dragging the glasses around to see how they affect what&rsquo;s seen through them:</p>
<div class="alpha_glass_container" id="alpha_rose_glasses_container"></div>
<p>The way these kind of glasses work is that they let through a lot of red light, a decent amount of blue light, and only some amount of green light. We can write down the math behind these specific glasses using the following set of three equations. The letter <strong>R</strong> is the result of the operation and the letter <strong>D</strong> describes the destination we&rsquo;re looking at. The RGB subscripts denote the red, green, and blue color components:</p>
<div class="alpha_equation">
R<sub>R</sub> = D<sub>R</sub> &times; 1.0<br>
R<sub>G</sub> = D<sub>G</sub> &times; 0.7<br>
R<sub>B</sub> = D<sub>B</sub> &times; 0.9
</div>
<p>This stained glass lets through red, green, and blue components of the background with different intensities. In other words, the <em>transparency</em> of the rose-tinted glasses depends on the color of the incoming light. In general, transparency can <a href="https://en.wikipedia.org/wiki/Electromagnetic_absorption_by_water#/media/File:Absorption_spectrum_of_liquid_water.png">vary with a wavelength of light</a>, but in this simplified situation we&rsquo;re only interested in how the glasses affect the classic RGB components.</p>
<p>A simulation of the behavior of regular sunglasses is much less complicated, they usually just attenuate some amount of the incoming light:</p>
<div class="alpha_glass_container" id="alpha_black_glasses_container"></div>
<p>These sunglasses let through only 30% of the light passing through them. We can describe this behavior using these equations:</p>
<div class="alpha_equation">
R<sub>R</sub> = D<sub>R</sub> &times; 0.3<br>
R<sub>G</sub> = D<sub>G</sub> &times; 0.3<br>
R<sub>B</sub> = D<sub>B</sub> &times; 0.3
</div>
<p>All three color components are scaled by the same value – the absorption of the incoming light is uniform. We could say that the dark glasses are 30% transparent, or we could say that they&rsquo;re 70% opaque. <em>Opacity</em> of an object defines how much light is blocked by it. In computer graphics we usually deal with a simplified model in which only a single value is needed to describe that property. Opacity can be spatially variant like in a case of a column of smoke which becomes more transparent the higher it goes.</p>
<p>In the real world objects with 100% opacity are just opaque and they don&rsquo;t let through any light. The world of digital imaging is slightly different. It has some, quite literally, edge cases where even solid opaque things can let through some amount of light.</p>
<h1 id="coverage">Coverage<a href="index.html#coverage" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Vector graphics deal with pristine and infinitely precise descriptions of shapes that are defined using points, linear segments, Bézier curves, and other mathematical primitives. When it comes to putting the shapes onto a computer screen, those immaculate beings have to be rasterized into a bitmap:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_rasterization.svg"
         alt="Rasterization of a vector shape into a bitmap" width="492" height="202"
    /> 
    </div><span>
            <p>Rasterization of a vector shape into a bitmap</p>
        </span>
</div>

<p>The most primitive way to do it is to check if a pixel sample is on the inside or on the outside of the vector shape. In the examples below you can drag the triangle on either zoomed or un-zoomed side, the latter lets you perform finer movements. The blue outline symbolizes the original vector geometry. As you can see the steps on the edges of the triangle look unpleasant and they flicker heavily when the geometry is moved:</p>
<div class="alpha_coverage_canvas_aspect_container" id="alpha_coverage_binary_canvas_container"></div>
<p>The flaw of this approach lies in the fact that we only do one test per output pixel and the results are quantized to one of the two possible values – in or out.</p>
<p>We could sample the vector geometry more than once per pixel to achieve a higher gradation of steps and decide that some pixels are covered only <em>partially</em>. One approach is to use four sample points which lets us represent five different levels of coverage: 0, 1/4, 2/4, 3/4, and 1:</p>
<div class="alpha_coverage_canvas_aspect_container" id="alpha_coverage_msaa_canvas_container"></div>
<p>The quality of the edges of the triangle is improved, but just five possible levels of coverage are very often not enough and we can easily do a much better job. While describing a pixel as a little square <a href="http://alvyray.com/Memos/CG/Microsoft/6_pixel.pdf">is frowned upon</a> in a world of signal processing, in some contexts it is a useful model that lets us calculate an accurate coverage of a pixel by the vector geometry. An intersection of a line with a square can always be decomposed into a <span style="background-color:rgba(82,143,237);border-radius: 0.2em;padding: 0 .2em;">trapezoid</span> and a <span style="background-color:#F7D44B;border-radius: 0.2em;padding: 0 .2em;">rectangle</span>:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_coverage_trap.svg"
         alt="A linear segment splits a square into a trapezoid and a rectangle" width="492" height="102"
    /> 
    </div><span>
            <p>A linear segment splits a square into a trapezoid and a rectangle</p>
        </span>
</div>

<p>The area of those two parts can be calculated relatively easily and their sum divided by the square&rsquo;s area specifies the percentage of a coverage of a pixel. That coverage is calculated as an exact number and can be arbitrarily precise. The demonstration below uses that method to render significantly better looking edges that stay smooth when the triangle is dragged around:</p>
<div class="alpha_coverage_canvas_aspect_container" id="alpha_coverage_geometry_canvas_container"></div>
<p>When it comes to more complicated shapes like ellipses or <a href="../drawing-bezier-curves/index.html">Bézier curves</a>, they&rsquo;re very often subdivided to simple linear segments allowing the coverage evaluation with as high accuracy as required.</p>
<p>Partial coverage is crucial for high quality rendering of vector graphics, including, most importantly, the rendering of text. If you look up close on a screenshot of this page you&rsquo;ll notice that almost all the edges of the glyphs end up covering the pixels only partially:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_glyphs@2x.png"
         alt="Text rendering heavily relies on partial coverage" width="408" height="224"
    /> 
    </div><span>
            <p>Text rendering heavily relies on partial coverage</p>
        </span>
</div>

<p>With the object&rsquo;s opacity in one hand and its coverage of individual pixels in another, we&rsquo;re ready to combine them into a single value.</p>
<h1 id="alpha">Alpha<a href="index.html#alpha" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>The product of an object&rsquo;s opacity and its pixel coverage is known as <em>alpha</em>:</p>
<div class="alpha_equation">
alpha = opacity &times; coverage
</div>
<p>An object that&rsquo;s 60% opaque that covers 30% of a pixel&rsquo;s area has an alpha value of 18% in that pixel. Naturally, when an object is transparent, or it doesn&rsquo;t cover a pixel at all, its value of alpha at that pixel is equal to 0. Once multiplied the distinction between the opacity and the coverage is lost which in some sense justifies the synonymous use of the terms &ldquo;alpha&rdquo; and &ldquo;opacity&rdquo;.</p>
<p>Alpha is often presented as a fourth channel of a bitmap. The usual values of red, green, and blue are accompanied by the alpha value to form the quadruple of RGBA values.</p>
<p><a id="alpha_text_bit_depth"></a>
When it comes to storing the alpha value in memory one could be tempted to use only a few bits. If you consider the pixel coverage of edges of opaque objects 4 or even 3 bits of alpha often look good enough, depending on the pixel density of your display:</p>
<div id="alpha_text_bit_canvas_container">
<canvas id="alpha_text_bit_canvas"></canvas>
</div>
<p>However, opacity also contributes to the alpha value so a low bit-depth may be catastrophic for quality of some smoothly varying transparencies. In the visualization below a gradient spanned between an opaque black and a clear color shows that low bit-depths result in very banded images:</p>
<div id="alpha_gradient_bit_canvas_container">
<canvas id="alpha_gradient_bit_canvas"></canvas>
</div>
<p>Clearly, the more bits the better and most commonly an alpha bit-depth of 8 is used to match the precision of the color components making many RGBA buffers occupy 32 bits per pixel. It&rsquo;s worth pointing out that unlike the color components which are often encoded using a non-linear transformation, alpha is stored linearly – encoded value of 0.5 corresponds to alpha value of 0.5.</p>
<p>So far when talking about alpha we&rsquo;ve completely ignored any color components, but other than blocking a background color a pixel can add some color on its own. The idea is fairly simple – a semi-transparent pink object blocks some of the incoming background light and emits, or reflects, some of the pink light:</p>
<div class="alpha_glass_container" id="alpha_rose_sover_glasses_container"></div>
<div class="alpha_segmented_container" id="alpha_pink_segment_container"></div>
<p>Note that this behaves <em>differently</em> from a stained glass. The glass merely blocks some of the background light with varying intensities. Looking at a pitch black object with rose-stained glass maintains the blackness since a black object doesn&rsquo;t emit or reflect any light in the first place. However, the semi-transparent pink object <em>adds</em> its own light. Placing it on top of a black object produces a pinkish result. A good equivalent of that behavior is a fine material suspended in the air, be it haze, smoke, fog, or some colorful powder.</p>
<p>Visualizing the alpha channel is a little complicated – a perfectly transparent object is by definition invisible, so I&rsquo;ll use two tricks to make things discernible. A checkerboard background shows which parts of the image are clear, a pattern used in many graphic design applications:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_convention_a.svg"
         alt="Checkerboard pattern showing clear parts" width="280" height="144"
    /> 
    </div><span>
            <p>Checkerboard pattern showing clear parts</p>
        </span>
</div>

<p>The four little squares under the image tell us we&rsquo;re looking at red, green, blue, and alpha components of the image. In some cases it&rsquo;s useful to see the values of the alpha channel directly and the easiest way to present them is by using shades of gray:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_convention_b.svg"
         alt="Showing RGB and A values as separate planes" width="280" height="306"
    /> 
    </div><span>
            <p>Showing RGB and A values as separate planes</p>
        </span>
</div>

<p>The brighter the gray the higher the alpha value and so pure black corresponds to 0% alpha and pure white means 100% alpha. The little squares show that RGB and A components of the image have been separated into two planes.</p>
<p>On its own the alpha component isn&rsquo;t particularly useful, but it becomes critical when we talk about compositing.</p>
<h1 id="simple-compositing">Simple Compositing<a href="index.html#simple-compositing" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Very few 2D rendering effects can be achieved with a single operation and we use the process of <em>compositing</em> to combine multiple images to create the final output. As an example, a simple &ldquo;Cancel&rdquo; button can be created by a composition of five separate elements:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_compositing.svg"
         alt="Compositing elements of a &amp;ldquo;Cancel&amp;rdquo; Button" width="318" height="328"
    /> 
    </div><span>
            <p>Compositing elements of a &ldquo;Cancel&rdquo; Button</p>
        </span>
</div>

<p>Compositing is often performed in multiple steps where each step combines two images. The usual name for the foreground image being composed is a <em>source</em>. The background image that is being composed into is called a <em>destination</em>. It&rsquo;s easy to remember if you think of it in terms of the new pixels from the source arriving at the destination.</p>
<p>We&rsquo;ll start with compositing against an opaque background since it is a very common case. Everything you see on your screen ultimately ends being composited into a non-transparent destination.</p>
<p>When the value of alpha of the source is 100% the source is opaque and it should cover the destination completely. For the alpha value of 0% the source is completely transparent and the destination should not be affected. Alpha value of 25% allows the object to emit 25% of its light and lets through 75% of the light from the background and so on:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_mix_lerp.svg"
         alt="Compositing of purple sources with various alpha values into a yellow destination" width="520" height="248"
    /> 
    </div><span>
            <p>Compositing of purple sources with various alpha values into a yellow destination</p>
        </span>
</div>

<p>You may see where this is all going – the simple case of alpha compositing against an opaque background is just a linear interpolation between the destination and the source colors. In the chart below the slider controls the alpha value of the source, while the red, green, and blue plots depict the values of the RGB components. The result <strong>R</strong> is just a mix between the source <strong>S</strong> and the destination <strong>D</strong>:</p>
<div id="alpha_lerper_container"></div>
<div class="alpha_slider_container" id="alpha_lerper_slider_container"></div>
<p>We can describe what&rsquo;s going on using the following equations. As before, the subscript denotes the component, so S<sub>A</sub> is the alpha value of the source, while D<sub>G</sub> is the green value of the destination:</p>
<div class="alpha_equation">
R<sub>R</sub> = S<sub>R</sub> &times; S<sub>A</sub> + D<sub>R</sub> &times; (1 &minus; S<sub>A</sub>)<br>
R<sub>G</sub> = S<sub>G</sub> &times; S<sub>A</sub> + D<sub>G</sub> &times; (1 &minus; S<sub>A</sub>)<br>
R<sub>B</sub> = S<sub>B</sub> &times; S<sub>A</sub> + D<sub>B</sub> &times; (1 &minus; S<sub>A</sub>)<br>
</div>
<p>The equations for the red, green, and blue components have the same form so we can just use an <sub>RGB</sub> subscript and combine everything into a single line:</p>
<div class="alpha_equation">
R<sub>RGB</sub> = S<sub>RGB</sub> &times; S<sub>A</sub> + D<sub>RGB</sub> &times; (1 &minus; S<sub>A</sub>)<br>
</div>
<p>Moreover, since the destination is opaque and already blocks all the background light we know that the alpha value of the result is always equal to 1:</p>
<div class="alpha_equation">
R<sub>A</sub> = 1
</div>
<p>Compositing against an opaque background is simple, but unfortunately quite limited. There are many cases where a more robust solution is needed.</p>
<h1 id="intermediate-buffers">Intermediate Buffers<a href="index.html#intermediate-buffers" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>In the image below you&rsquo;ll see a two step process of compositing three different layers marked as: <span class="alpha_layer">A</span>, <span class="alpha_layer">B</span>, and <span class="alpha_layer">C</span>. I&rsquo;ll use symbol ⇨ to denote &ldquo;composed onto&rdquo;:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_sover_assoc_a.svg"
         alt="Compositing result of three layers in two steps" width="620" height="310"
    /> 
    </div><span>
            <p>Compositing result of three layers in two steps</p>
        </span>
</div>

<p>We first compose <span class="alpha_layer">B</span> onto <span class="alpha_layer">C</span>, and then we compose <span class="alpha_layer">A</span> onto that to achieve the final image. In the next example we&rsquo;re going to do things slightly differently. We&rsquo;ll compose the two topmost layers first, and then we&rsquo;ll compose that result into the final destination:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_sover_assoc_b.svg"
         alt="Compositing result of three layers in two steps with different order" width="620" height="310"
    /> 
    </div><span>
            <p>Compositing result of three layers in two steps with different order</p>
        </span>
</div>

<p>You may wonder if that situation happens in practice, but it&rsquo;s actually very common. A lot of non-trivial compositing and rendering effects like masking and blurring require a step through an intermediate buffer that contains only partial results of compositing. That concept is known under different names: offscreen passes, transparency layers, or side buffers, but the idea is usually the same.</p>
<p>More importantly, almost <em>any</em> image with transparency can be thought of as a partial result of some rendering that, at some later time, will be composed to its final destination:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_precompose.svg"
         alt="Partial composition of a button into a buffer" width="128" height="48"
    /> 
    </div><span>
            <p>Partial composition of a button into a buffer</p>
        </span>
</div>

<p>We want to figure out how to replace the composition of semi-transparent images <span class="alpha_layer">A</span> and <span class="alpha_layer">B</span> with a single image (<span class="alpha_layer">A</span>⇨<span class="alpha_layer">B</span>) that will have the same color and opacity. Let&rsquo;s start by calculating the alpha value of the resulting buffer.</p>
<h1 id="combining-alphas">Combining Alphas<a href="index.html#combining-alphas" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>It may be unclear how to combine opacities of two objects, but it&rsquo;s easier to reason about the issue when we think about the transparencies instead.</p>
<p>Consider some amount of light passing through a first object and then through a second object. If the transparency of the first object is 80%, it will let through 80% of the incoming light. Similarly, a second object with transparency 60% will let through 60% of the light passing through it, which is 60% × 80% = 48% of the original light. You can <a href="index.html#" onclick="alpha_set_transparencies();return false;">try</a> this in a demonstration below, remember that the sliders control <em>transparency</em> and not opacity of the objects in the path of light:</p>
<div id="alpha_alpha_mul_canvas_container"></div>
<div class="alpha_slider_container" id="alpha_alpha_mul_red_container"></div>
<div class="alpha_slider_container" id="alpha_alpha_mul_blue_container"></div>
<p>Naturally, when either <a href="index.html#" onclick="alpha_set_transparencies0();return false;">the first</a> or <a href="index.html#" onclick="alpha_set_transparencies1();return false;">the second</a> object is opaque no light passes through even when the other one is fully transparent.</p>
<p>If an object D has transparency D<sub>T</sub> and object S has transparency S<sub>T</sub>, then the resulting transparency R<sub>T</sub> of those two objects combined is equal to their product:</p>
<div class="alpha_equation">
R<sub>T</sub> = D<sub>T</sub> &times; S<sub>T</sub>
</div>
<p>However, transparency is just one minus alpha, so a substitution gets us:</p>
<div class="alpha_equation">
1 &minus; R<sub>A</sub> = (1 &minus; D<sub>A</sub>) &times; (1 &minus; S<sub>A</sub>)
</div>
<p>Which expands to:</p>
<div class="alpha_equation">
1 &minus; R<sub>A</sub> = 1 &minus; D<sub>A</sub> &minus; S<sub>A</sub> + D<sub>A</sub> &times; S<sub>A</sub>
</div>
<p>And simplifies to:</p>
<div class="alpha_equation">
R<sub>A</sub> = D<sub>A</sub> + S<sub>A</sub> &minus; D<sub>A</sub> &times; S<sub>A</sub>
</div>
<p>This can be further minimized to one of the two equivalent forms:</p>
<div class="alpha_equation">
R<sub>A</sub> = S<sub>A</sub> + D<sub>A</sub> &times; (1 &minus; S<sub>A</sub>)<br>
R<sub>A</sub> = D<sub>A</sub> + S<sub>A</sub> &times; (1 &minus; D<sub>A</sub>)
</div>
<p>We&rsquo;ll soon see that the former is more commonly used. As an interesting side note, notice that the resulting alpha doesn&rsquo;t depend on the relative order of the objects – the opacity of the resulting pixels is the same even when the source and destination are switched. This makes a lot of sense. A light passing through two objects should be equally dimmed when it&rsquo;s shining front to back or back to front.</p>
<h1 id="combining-colors">Combining Colors<a href="index.html#combining-colors" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Calculating alpha wasn&rsquo;t that difficult so let&rsquo;s try to reason through the math behind the RGB components. The source image has a color S<sub>RGB</sub>, but its opacity S<sub>A</sub> causes it to contribute only the product of those two values to the final result:</p>
<div class="alpha_equation">
S<sub>RGB</sub>&times;S<sub>A</sub>
</div>
<p>The destination image has a color D<sub>RGB</sub>, its opacity causes it to emit D<sub>RGB</sub>×D<sub>A</sub> light, however, some part of that light is blocked by opacity of S so the entire contribution from the destination is equal to:</p>
<div class="alpha_equation">
D<sub>RGB</sub>&times;D<sub>A</sub>&times;(1 &minus; S<sub>A</sub>)
</div>
<p>The total light contribution from both S and D is equal to their sum:</p>
<div class="alpha_equation">
S<sub>RGB</sub>&times;S<sub>A</sub> + D<sub>RGB</sub>&times;D<sub>A</sub>&times;(1 &minus; S<sub>A</sub>)
</div>
<p>Similarly, the contribution of the merged layers is equal to their color times their opacity:</p>
<div class="alpha_equation">
R<sub>RGB</sub>&times;R<sub>A</sub>
</div>
<p>We want those two values to match:</p>
<div class="alpha_equation">
R<sub>RGB</sub>&times;R<sub>A</sub> = S<sub>RGB</sub>&times;S<sub>A</sub> + D<sub>RGB</sub>&times;D<sub>A</sub>&times;(1 &minus; S<sub>A</sub>)
</div>
<p>Which gives us the final equations:</p>
<div class="alpha_equation">
R<sub>A</sub> = S<sub>A</sub> + D<sub>A</sub> &times; (1 &minus; S<sub>A</sub>)<br>
R<sub>RGB</sub> = (S<sub>RGB</sub>&times;S<sub>A</sub> + D<sub>RGB</sub>&times;D<sub>A</sub>&times;(1 &minus; S<sub>A</sub>)) / R<sub>A</sub>
</div>
<p>Look how complicated the second equation is! Notice that to obtain the RGB values of the result we have to do a division by the alpha value. However, any subsequent compositing step will require a multiplication by the alpha value again, since the result of a current operation will become a new source or destination in the next operation. This is just inelegant.</p>
<p>Let&rsquo;s go back to the almost final form of R<sub>RGB</sub> for a second:</p>
<div class="alpha_equation">
R<sub>RGB</sub>&times;R<sub>A</sub> = S<sub>RGB</sub>&times;S<sub>A</sub> + D<sub>RGB</sub>&times;D<sub>A</sub>&times;(1 &minus; S<sub>A</sub>)
</div>
<p>The source, the destination, <em>and</em> the result are multiplied by their alpha components. This hints us that the pixel&rsquo;s color and its alpha like to be together, so let&rsquo;s try to take a step back and rethink the way we store the color information.</p>
<h1 id="premultiplied-alpha">Premultiplied Alpha<a href="index.html#premultiplied-alpha" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Recall how we talked about opacity – if the object is partially opaque the contribution of its color to the output is also partial. Premultiplied alpha makes this idea explicit. The values of the RGB components are, as the name implies, premultiplied by the alpha component. Starting with a non-premultiplied color:</p>
<div class="alpha_equation">
(<span class="alpha_r">1.00</span>, <span class="alpha_g">0.80</span>, <span class="alpha_b">0.30</span>, <span class="alpha_a">0.40</span>)
</div>
<p>Alpha premultiplication results in:</p>
<div class="alpha_equation">
(<span class="alpha_r">0.40</span>, <span class="alpha_g">0.32</span>, <span class="alpha_b">0.12</span>, <span class="alpha_a">0.40</span>)
</div>
<p>Let&rsquo;s look at more than one pixel at the time. The following picture shows how color information is stored in a non-premultiplied alpha:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_non_premul.svg"
         alt="RGB and A information in a non-premultiplied image" width="440" height="262"
    /> 
    </div><span>
            <p>RGB and A information in a non-premultiplied image</p>
        </span>
</div>

<p>Notice that the areas where alpha is 0 can have arbitrary RGB values as shown by the green and cyan glitches in the image. With premultiplied alpha the color information also carries the values of pixel&rsquo;s opacity:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_premul.svg"
         alt="RGB and A information in a premultiplied image" width="440" height="262"
    /> 
    </div><span>
            <p>RGB and A information in a premultiplied image</p>
        </span>
</div>

<p>Premultiplied alpha is sometimes called associated alpha, while non-premultiplied alpha is occasionally referred to as straight or unassociated alpha.</p>
<p>When the alpha component of a color is equal to 0, the premultiplication nullifies all the other components, regardless of what was in them:</p>
<div class="alpha_equation">
(<span class="alpha_r">0.0</span>, <span class="alpha_g">0.0</span>, <span class="alpha_b">0.0</span>, <span class="alpha_a">0.0</span>)
</div>
<p>With premultiplied alpha there is only <em>one</em> completely transparent color – a charming simplicity.</p>
<p>The benefits of this treatment of color components may slowly start to become clear, but before we go back to our compositing example let&rsquo;s see how premultiplied alpha helps to solve some other rendering issues.</p>
<h2 id="filtering">Filtering<a href="index.html#filtering" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>A <a href="https://en.wikipedia.org/wiki/Gaussian_blur">gaussian blur</a> is a popular way to either provide an interesting unfocused background, or as a way of reducing the <a href="https://photo.stackexchange.com/questions/40401/what-does-frequency-mean-in-an-image">high frequency</a> of the underlying contents in some UI elements. As we&rsquo;ll see alpha premultiplication is critical to achieve correctly looking blurs.</p>
<p>The image we&rsquo;ll analyze is created by filling the background with 1% opaque blue color and then painting an opaque red circle on top. First, let&rsquo;s consider a non-premultiplied example. I separated RGB channels from the alpha channel to make it easier to see what&rsquo;s going on. The arrow symbolizes the blur operation:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_nonpremul_blur@2x.png"
         alt="Blurring non-premultiplied content" width="530" height="264"
    /> 
    </div><span>
            <p>Blurring non-premultiplied content</p>
        </span>
</div>

<p>The final result has an ugly blue halo around it. This happens because the blue background seeps into the red area during the blur and <em>then</em> it&rsquo;s weighted by the alpha at composite time.</p>
<p>When the colors are alpha premultiplied the final result is correct:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_premul_blur@2x.png"
         alt="Blurring premultiplied content" width="530" height="264"
    /> 
    </div><span>
            <p>Blurring premultiplied content</p>
        </span>
</div>

<p>Due to the premultiplication the blue color in the image is reduced to 1% of its original strength so its impact on the colors of the blurred circle is expectedly minimal.</p>
<h2 id="interpolation">Interpolation<a href="index.html#interpolation" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Rendering an image whose pixels are perfectly aligned with a destination is easy since we have a trivial one-to-one mapping between the samples. A problem arises when the simple mapping doesn&rsquo;t exist, e.g. due to rotation, scaling, or translation. In the picture below you can see how the pixels of a rotated image shown with a red outline no longer align with a destination:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_sampling.svg"
         alt="Relative orientation of image and destination pixels before and after rotation" width="596" height="290"
    /> 
    </div><span>
            <p>Relative orientation of image and destination pixels before and after rotation</p>
        </span>
</div>

<p>There are multiple ways of deciding which color from the image should be put into the destination pixel and the easiest option is a so called nearest-neighbor interpolation which simply chooses the nearest sample in the texture as the resulting color.</p>
<p>In the demonstration below the red outline shows the position of the image in the destination. The right side presents the sample positions from the point of view of <em>the image</em>. By dragging the slider you can rotate the quad to see how the samples pick up colors from the bitmap. I highlighted a single pixel in both the source and the destination to make it easier to see how they relate:</p>
<div class="alpha_sampler_canvas_container" id="alpha_nearest_sampler"></div>
<div class="alpha_slider_container" id="alpha_nearest_slider_container"></div>
<p>That approach works and the pixels are consistently colored, but the quality is unacceptable. A better way to do it is to use <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">bilinear interpolation</a> which calculates a weighted average of the four nearest pixels in the sampled image:</p>
<div class="alpha_sampler_canvas_container" id="alpha_bilinear_bad_sampler"></div>
<div class="alpha_slider_container" id="alpha_bilinear_bad_slider_container"></div>
<p>This is better, but the edges around the rectangles just don&rsquo;t look right, the contents of the non-premultiplied pixels bleeds in since the alpha is &ldquo;applied&rdquo; after interpolation. The sometimes recommended approach of bleeding the color of the valid contents out, which you can see some examples of in Adrian Courrèges' <a href="http://www.adriancourreges.com/blog/2017/05/09/beware-of-transparent-pixels/">fantastic article</a>, is far from perfect – no color would make the one pixel gap between the red and the blue rectangle look correct.</p>
<p>Let&rsquo;s see how things look when an image is alpha premultiplied, and, to foreshadow a little, composited using a better equation that we&rsquo;ll derive in a minute:</p>
<div class="alpha_sampler_canvas_container" id="alpha_bilinear_sampler"></div>
<div class="alpha_slider_container" id="alpha_bilinear_slider_container"></div>
<p>It&rsquo;s just perfect, we got rid of all the color bleeding and <a href="https://en.wikipedia.org/wiki/Jaggies">jaggies</a> are nowhere to be seen.</p>
<p>The issues related to blurring and interpolation are ultimately closely related. Any operation that requires some combination of semi-transparent colors will likely have incorrect results unless the colors are alpha premultiplied.</p>
<h1 id="compositing-done-right">Compositing Done Right<a href="index.html#compositing-done-right" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Let&rsquo;s jump back to compositing. We&rsquo;ve left the discussion with the almost finished derivation:</p>
<div class="alpha_equation">
R<sub>RGB</sub>&times;R<sub>A</sub> = S<sub>RGB</sub>&times;S<sub>A</sub> + D<sub>RGB</sub>&times;D<sub>A</sub>&times;(1 &minus; S<sub>A</sub>)
</div>
<p>If we represent the colors using premultiplied alpha all those pesky multiplications disappear since they&rsquo;re already part of the color values and we end up with:</p>
<div class="alpha_equation">
R<sub>RGB</sub> = S<sub>RGB</sub> + D<sub>RGB</sub>&times;(1 &minus; S<sub>A</sub>)
</div>
<p>Let&rsquo;s have a look at the equation for the alpha:</p>
<div class="alpha_equation">
R<sub>A</sub> = S<sub>A</sub> + D<sub>A</sub> &times; (1 &minus; S<sub>A</sub>)<br>
</div>
<p>The factors for red, green, blue, and alpha channels are all the same, so we can just express the entire thing using a single equation and just remember that every component undergoes the same operation:</p>
<div class="alpha_equation">
R = S + D &times; (1 &minus; S<sub>A</sub>)
</div>
<p>Look how premultiplied alpha made things beautifully simple. When we analyze the components of the equation they all fit right in. The operation <span class="alpha_c3">masks</span> <span class="alpha_c4">some</span> <span class="alpha_c2">background light</span> and <span class="alpha_c1">adds</span> <span class="alpha_c0">new light</span>:</p>
<div class="alpha_equation">
R = <span class="alpha_c0">S</span> <span class="alpha_c1">+</span> <span class="alpha_c2">D</span> <span class="alpha_c3">&times;</span> <span class="alpha_c4">(1 &minus; S<sub>A</sub>)</span>
</div>
<p>This blending operation is known as <span class="alpha_operator">source-over</span>, <span class="alpha_operator">sover</span>, or just <span class="alpha_operator">normal</span>, and, without a doubt, it is the most commonly used compositing mode. Almost everything you see on this website was blended using this mode.</p>
<h2 id="associativity">Associativity<a href="index.html#associativity" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>An important feature of the <span class="alpha_operator">source-over</span> on premultiplied colors is that it&rsquo;s <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a>. In a complex blending equation this lets us put the parentheses completely arbitrarily. All compositions below are equivalent:</p>
<div class="alpha_equation">
R = (((<span class="alpha_layer">A</span>&#8680;<span class="alpha_layer">B</span>)&#8680;<span class="alpha_layer">C</span>)&#8680;<span class="alpha_layer">D</span>)&#8680;<span class="alpha_layer">E</span>
<br>
R = (<span class="alpha_layer">A</span>&#8680;<span class="alpha_layer">B</span>)&#8680;(<span class="alpha_layer">C</span>&#8680;(<span class="alpha_layer">D</span>&#8680;<span class="alpha_layer">E</span>))
<br>
R = <span class="alpha_layer">A</span>&#8680;(<span class="alpha_layer">B</span>&#8680;(<span class="alpha_layer">C</span>&#8680;(<span class="alpha_layer">D</span>&#8680;<span class="alpha_layer">E</span>)))
</div>
<p>The proof is fairly simple, but I won&rsquo;t bore you with the algebraic manipulations. The practical implication is that we can perform partial renders of complicated drawings without a fear that the final composition will look any different.</p>
<p>The vast majority of time the alpha is used purely for <span class="alpha_operator">source-over</span> compositing, however, its power doesn&rsquo;t stop there. We can use the alpha values for other useful rendering operations.</p>
<h1 id="porter-duff">Porter-Duff<a href="index.html#porter-duff" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>In July 1984 Thomas Porter and Tom Duff have published a seminal paper entitled <a href="https://keithp.com/~keithp/porterduff/p253-porter.pdf">&ldquo;Compositing Digital Images&rdquo;</a>. The authors not only introduced the concept of premultiplied alpha and derived the equation behind <span class="alpha_operator">source-over</span> compositing, but they also presented an entire family of alpha compositing operations, many of which are not well know despite being very useful. The introduced functions are also known as <em>operators</em>, since, similarly to addition or multiplication, they operate on input values to create an output value.</p>
<h2 id="over">Over<a href="index.html#over" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>In the following examples we&rsquo;ll use the interactive demos that show how different blend modes operate. The destination has a black clubs symbol ♣, while the source has a red hearts symbol <span style="color:red">♥</span>. You can drag the heart around to see how the overlap of the two shapes behaves under different compositing operators. Notice the little minimap in the corner. Some blend modes are quite destructive and it may be easy to lose track of what&rsquo;s where. The minimap always shows a result of the simple <span class="alpha_operator">source-over</span> compositing which should make it easier to navigate:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_over_canvas_container"></div>
<div class="alpha_segmented_container" id="alpha_over_segment_container"></div>
<div class="alpha_equation" id="alpha_sover_equation">
R = S + D &times; (1 &minus; S<sub>A</sub>)
</div>
<div class="alpha_equation" id="alpha_dover_equation">
R = S &times; (1 &minus; D<sub>A</sub>) + D
</div>
<p>If you switch to <span class="alpha_operator">destination-over</span> you&rsquo;ll quickly realize it&rsquo;s just a &ldquo;flipped&rdquo; <span class="alpha_operator">source-over</span>, the destination and source swap places in the equation and the result is equivalent to treating the source as the destination and the destination as the source. While seemingly redundant, the <span class="alpha_operator">destination-over</span> operator is quite useful as it lets us composite things <em>behind</em> already existing contents.</p>
<h2 id="out">Out<a href="index.html#out" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>The <span class="alpha_operator">source-out</span> and <span class="alpha_operator">destination-out</span> operators are great for punching holes in the source and destination respectively:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_out_canvas_container"></div>
<div class="alpha_segmented_container" id="alpha_out_segment_container"></div>
<div class="alpha_equation" id="alpha_sout_equation">
R = S &times; (1 &minus; D<sub>A</sub>)
</div>
<div class="alpha_equation" id="alpha_dout_equation">
R = D &times; (1 &minus; S<sub>A</sub>)
</div>
<p><span class="alpha_operator">Destination-out</span> is the more convenient operator of the two, it uses the alpha channel of the source to punch out the existing destination.</p>
<h2 id="in">In<a href="index.html#in" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>The <span class="alpha_operator">source-in</span> and <span class="alpha_operator">destination-in</span> are essentially masking operators:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_in_canvas_container"></div>
<div class="alpha_segmented_container" id="alpha_in_segment_container"></div>
<div class="alpha_equation" id="alpha_sin_equation">
R = S &times; D<sub>A</sub>
</div>
<div class="alpha_equation" id="alpha_din_equation">
R = D &times; S<sub>A</sub>
</div>
<p>They make it fairly easy to obtain complex intersections of complicated geometry without resolving to relatively difficult to compute intersections of vector-based paths.</p>
<h2 id="atop">Atop<a href="index.html#atop" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>The <span class="alpha_operator">source-atop</span> and <span class="alpha_operator">destination-atop</span> allow overlaying of new contents on top of existing one, while simultaneously masking it to the destination:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_atop_canvas_container"></div>
<div class="alpha_segmented_container" id="alpha_atop_segment_container"></div>
<div class="alpha_equation" id="alpha_satop_equation">
R = S &times; D<sub>A</sub> + D &times; (1 &minus; S<sub>A</sub>)
</div>
<div class="alpha_equation" id="alpha_datop_equation">
R = S &times; (1 &minus; D<sub>A</sub>) + D &times; S<sub>A</sub>
</div>
<h2 id="xor">Xor<a href="index.html#xor" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>The exclusive-or operator or just <span class="alpha_operator">xor</span> keeps <em>either</em> the source or the destination, their overlap disappears:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_xor_canvas_container"></div>
<div class="alpha_equation">
R = S &times; (1 &minus; D<sub>A</sub>) + D &times; (1 &minus; S<sub>A</sub>)
</div>
<h2 id="source-destination-clear">Source, Destination, Clear<a href="index.html#source-destination-clear" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>The last three classic compositing mode are rather dull. <span class="alpha_operator">Source</span>, also known as <span class="alpha_operator">copy</span> just takes the source color. Similarly, <span class="alpha_operator">destination</span> ignores the source color and simply returns the destination. Finally, <span class="alpha_operator">clear</span> simply wipes everything:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_sdc_canvas_container"></div>
<div class="alpha_segmented_container" id="alpha_sdc_segment_container"></div>
<div class="alpha_equation" id="alpha_s_equation">
R = S
</div>
<div class="alpha_equation" id="alpha_d_equation">
R = D
</div>
<div class="alpha_equation" id="alpha_c_equation">
R = 0
</div>
<p>The usefulness of those modes is limited. A dirty buffer may be reset using <span class="alpha_operator">clear</span> which can be optimized to just filling memory with zeros. Additionally, in some cases <span class="alpha_operator">source</span> <em>may</em> be cheaper to evaluate since it doesn&rsquo;t require any blending at all, it just replaces the contents of a buffer with source.</p>
<h1 id="porter-duff-in-action">Porter-Duff in Action<a href="index.html#porter-duff-in-action" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>With the individual operators out of the way let&rsquo;s see how we can combine them. In the example below we&rsquo;ll paint a nautical motif in nine steps without using any masking or complex geometrical shapes. The blue outlines show the simple geometry that is emitted. You can advance the steps by <span class="click_word">clicking</span><span class="tap_word">tapping</span> on the right half of the image and go back by <span class="click_word">clicking</span><span class="tap_word">tapping</span> on the left half of the image:</p>
<div class="alpha_pd_canvas_container" id="alpha_pd_example_container"></div>
<div class="alpha_equation" id="alpha_pd_example_step">
</div>
<p>You should by no means forget about masks and clip paths, but Porter-Duff compositing modes are an often forgotten tool that makes some visuals effects much easier to achieve.</p>
<h2 id="operators">Operators<a href="index.html#operators" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>If you ponder on the Porter-Duff operators we&rsquo;ve discussed you may notice that they all have the same form. A source is always multiplied by some factor <span class="alpha_c4">F<sub>S</sub></span> and added to the destination multiplied by a factor <span class="alpha_c2">F<sub>D</sub></span>:</p>
<div class="alpha_equation">
R = S&times;<span class="alpha_c4">F<sub>S</sub></span> + D&times;<span class="alpha_c2">F<sub>D</sub></span>
</div>
<p>Possible values of the <span class="alpha_c4">F<sub>S</sub></span> are <span class="alpha_c4">0</span>, <span class="alpha_c4">1</span>, <span class="alpha_c4">D<sub>A</sub></span>, and <span class="alpha_c4">1 − D<sub>A</sub></span>, while <span class="alpha_c2">F<sub>D</sub></span> can be either <span class="alpha_c2">0</span>, <span class="alpha_c2">1</span>, <span class="alpha_c2">S<sub>A</sub></span>, or <span class="alpha_c2">1 − S<sub>A</sub></span>. It doesn&rsquo;t make much sense to multiply the source or destination by their respective alphas since they&rsquo;re already premultiplied and we&rsquo;d just achieve a wacky, but not particularly useful alpha-squaring effect. We can present all the operators in a table:</p>
<table id="alpha_pd_table_big">
<tbody>
<tr>
<td></td>
<td><span class="alpha_c4">0</span></td>
<td><span class="alpha_c4">1</span></td>
<td><span class="alpha_c4">D<sub>A</sub></span></td>
<td><span class="alpha_c4">1 − D<sub>A</sub></span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">0</span></td>
<td><span class="alpha_operator">clear</span></td>
<td><span class="alpha_operator">source</span></td>
<td><span class="alpha_operator">source-in</span></td>
<td><span class="alpha_operator">source-out</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">1</span></td>
<td><span class="alpha_operator">destination</span></td>
<td></td>
<td></td>
<td><span class="alpha_operator">destination-over</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">S<sub>A</sub></span></td>
<td><span class="alpha_operator">destination-in</span></td>
<td></td>
<td></td>
<td><span class="alpha_operator">destination-atop</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">1 − S<sub>A</sub></span></td>
<td><span class="alpha_operator">destination-out</span></td>
<td><span class="alpha_operator">source-over</span></td>
<td><span class="alpha_operator">source-atop</span></td>
<td><span class="alpha_operator">xor</span></td>
</tr>
</tbody>
</table>
<table id="alpha_pd_table_mid">
<tbody>
<tr>
<td></td>
<td><span class="alpha_c4">0</span></td>
<td><span class="alpha_c4">1</span></td>
<td><span class="alpha_c4">D<sub>A</sub></span></td>
<td><span class="alpha_c4">1 − D<sub>A</sub></span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">0</span></td>
<td><span class="alpha_operator">clear</span></td>
<td><span class="alpha_operator">source</span></td>
<td><span class="alpha_operator">source-in</span></td>
<td><span class="alpha_operator">source-out</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">1</span></td>
<td><span class="alpha_operator">dest</span></td>
<td></td>
<td></td>
<td><span class="alpha_operator">dest-over</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">S<sub>A</sub></span></td>
<td><span class="alpha_operator">dest-in</span></td>
<td></td>
<td></td>
<td><span class="alpha_operator">dest-atop</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">1 − S<sub>A</sub></span></td>
<td><span class="alpha_operator">dest-out</span></td>
<td><span class="alpha_operator">source-over</span></td>
<td><span class="alpha_operator">source-atop</span></td>
<td><span class="alpha_operator">xor</span></td>
</tr>
</tbody>
</table>
<table id="alpha_pd_table_small">
<tbody>
<tr>
<td></td>
<td><span class="alpha_c4">0</span></td>
<td><span class="alpha_c4">1</span></td>
<td><span class="alpha_c4">D<sub>A</sub></span></td>
<td><span class="alpha_c4">1 − D<sub>A</sub></span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">0</span></td>
<td><span class="alpha_operator">clear</span></td>
<td><span class="alpha_operator">s</span></td>
<td><span class="alpha_operator">sin</span></td>
<td><span class="alpha_operator">sout</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">1</span></td>
<td><span class="alpha_operator">d</span></td>
<td></td>
<td></td>
<td><span class="alpha_operator">dover</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">S<sub>A</sub></span></td>
<td><span class="alpha_operator">din</span></td>
<td></td>
<td></td>
<td><span class="alpha_operator">datop</span></td>
</tr>
<tr>
<td style="text-align:right"><span class="alpha_c2">1 − S<sub>A</sub></span></td>
<td><span class="alpha_operator">dout</span></td>
<td><span class="alpha_operator">sover</span></td>
<td><span class="alpha_operator">satop</span></td>
<td><span class="alpha_operator">xor</span></td>
</tr>
</tbody>
</table>
<p>Notice the symmetry of the operators along the diagonal. The four central entries in the table are missing and that&rsquo;s cause they&rsquo;re unlike the others.</p>
<h1 id="additive-lighting">Additive Lighting<a href="index.html#additive-lighting" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>In their paper Porter and Duff presented one more operator created when both <span class="alpha_c4">F<sub>S</sub></span> and <span class="alpha_c2">F<sub>D</sub></span> are equal to 1. It&rsquo;s known as <span class="alpha_operator">plus</span>, <span class="alpha_operator">lighter</span>, or <span class="alpha_operator">plus-lighter</span>:</p>
<div class="alpha_equation">
R = S + D
</div>
<p>This operation effectively <em>adds</em> source light to the destination:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_additive@2x.png"
         alt="Additive light with the plus operator" width="488" height="226"
    /> 
    </div><span>
            <p>Additive light with the <em>plus</em> operator</p>
        </span>
</div>

<p>Green and red correctly created yellow, while green and blue produced cyan. The black color is a no-op – it doesn&rsquo;t modify the color values in any way since adding zero to a number doesn&rsquo;t do anything.</p>
<p>The three remaining operators were never named and that&rsquo;s cause they&rsquo;re not particularly useful. They&rsquo;re simply a combination of masking and additive blending.</p>
<p>It&rsquo;s also worth noting that premultiplied alpha lets us abuse the <span class="alpha_operator">source-over</span> operator. Let&rsquo;s look at the equation again:</p>
<div class="alpha_equation">
R = S + D &times; (1 &minus; S<sub>A</sub>)
</div>
<p>If we manage to make the alpha value of the source equal to zero, but have non-zero values in RGB channels we can achieve additive lighting without using <span class="alpha_operator">plus</span> operator:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_additive_sover@2x.png"
         alt="Additive light with the source-over operator" width="488" height="290"
    /> 
    </div><span>
            <p>Additive light with the <em>source-over</em> operator</p>
        </span>
</div>

<p>Note that you have to be careful – the values are no longer correctly premultiplied. Some pieces of software may have an optimization that avoids blending colors with zero alpha completely, while others may un-premultiply the alpha values, do some color operations, and then premultiply again which would wipe the color channels completely. It may also be difficult to export assets in that format, so you should stick to <span class="alpha_operator">plus</span> unless you control your rendering pipeline completely.</p>
<p>So far all the pieces I&rsquo;ve talked about have fit together gracefully. Let&rsquo;s take the rose-tinted glasses off and discuss some of the issues that one should be aware of when dealing with alpha compositing.</p>
<h1 id="group-opacity">Group Opacity<a href="index.html#group-opacity" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Let&rsquo;s look at this simple drawing of a pill done using just six primitives:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_group_pill@2x.png"
         alt="Drawing a pill using simple shapes" width="512" height="208"
    /> 
    </div><span>
            <p>Drawing a pill using simple shapes</p>
        </span>
</div>

<p>If we were asked to render the pill at 50% opacity one could be tempted to just halve the opacity of every drawing operation, however, it proves to be a faulty approach:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_group_opacity_bad@2x.png"
         alt="Unexpected rendering of a pill at half opacity" width="160" height="96"
    /> 
    </div><span>
            <p>Unexpected rendering of a pill at half opacity</p>
        </span>
</div>

<p>To achieve the correct result we can&rsquo;t just distribute object&rsquo;s opacity into each of its individual components. We have to create the object first by rendering it to a bitmap, <em>then</em> modify the opacity of that bitmap, and finally compose:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_group_opacity_good@2x.png"
         alt="Expected rendering of a pill at half opacity" width="512" height="96"
    /> 
    </div><span>
            <p>Expected rendering of a pill at half opacity</p>
        </span>
</div>

<p>This is yet another case when the concept of rendering into a side buffer shows its usefulness.</p>
<h1 id="compositing-coverage">Compositing Coverage<a href="index.html#compositing-coverage" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Conversion of geometrical coverage to a single alpha value has some unfortunate consequences. Consider a case in which two perfectly overlapping edges of vector geometry, depicted below with orange and blue outlines, are rendered into a bitmap. In an ideal world the results should look something like this since each pixel is perfectly covered:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_coverage_multi.svg"
         alt="An ideal result of rendering with correct coverage" width="555" height="255"
    /> 
    </div><span>
            <p>An ideal result of rendering with correct coverage</p>
        </span>
</div>

<p>However, if we first render the orange geometry and then the blue geometry the edge pixels of the result will still have some white background bleeding in:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_coverage_sover.svg"
         alt="Two-step composited result" width="555" height="255"
    /> 
    </div><span>
            <p>Two-step composited result</p>
        </span>
</div>

<p>Once the coverage is stored in the alpha channel all its geometrical information is lost and there is no way to recreate it. The blue geometry just blends with <em>some</em> contents in the buffer but it simply can&rsquo;t know that the geometry behind the reddish pixels was intended to match it. This issue is particularly visible when the geometries are perfectly overlapping. In the picture below a white circle is painted on top of black circle. You can see the dark edges despite both circles having the <em>exact</em> same radius and position:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_circle_overlap.svg"
         alt="A white circle drawn on top of a black circle" width="180" height="180"
    /> 
    </div><span>
            <p>A white circle drawn on top of a black circle</p>
        </span>
</div>

<p>One way to avoid this problem is to <em>not</em> calculate partial coverage of pixels, but instead use significantly scaled-up buffers. By rasterizing the vector geometry with a simple in/out coverage and then scaling the final result down to the original size we can achieve the expected outcome.</p>
<p>However, to perfectly match the quality of edge rendering of an 8-bit alpha channel the buffers would have to be 256 times larger in <em>both</em> directions, an increase in number of pixels by a whooping factor of 2<sup>16</sup>.
As <a href="index.html#alpha_text_bit_depth">we&rsquo;ve seen</a>, reducing bit-depth for coverage can still produce satisfying results so in practice smaller scales could be used.</p>
<p>It&rsquo;s worth noting that those issues can often be avoided relatively easily even without using any super-sized bitmaps. For example, instead of drawing two overlapping circles one could just draw two squares on top of each other and <em>then</em> mask the result to the shape of the circle.</p>
<h1 id="linear-values">Linear Values<a href="index.html#linear-values" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>If you had a chance to brush up your knowledge of <a href="../color-spaces.html">color spaces</a> you may remember that most of them encode the color values nonlinearly and performing correct mathematical operations requires a prior linearization. When that step is done the result of compositing looks as follows, notice they nicely yellowish tint of the overlapping parts:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_linear_sover@2x.png"
         alt="Fuzzy red circles composited on a green background using linear values" width="280" height="300"
    /> 
    </div><span>
            <p>Fuzzy red circles composited on a green background using linear values</p>
        </span>
</div>

<p>For better or for worse, this is <em>not</em> how most compositing works. The default way to do things on the web and in most graphic design software is to directly blend non-linear values:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_nonlinear_sover@2x.png"
         alt="Fuzzy red circles composited on a green background using non-linear values" width="280" height="300"
    /> 
    </div><span>
            <p>Fuzzy red circles composited on a green background using non-linear values</p>
        </span>
</div>

<p>See how much darker the overlap between the reds and the greens is. This is far from perfect, but there are some cases when doing things incorrectly has become deeply ingrained in the way we think about color. For example, opaque 50% gray from sRGB space looks exactly the same as pure black at 50% opacity blended with a white background:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_blend_srgb.svg"
         alt="Composition of two colors against a white background without linearization" width="405" height="133"
    /> 
    </div><span>
            <p>Composition of two colors against a white background <em>without</em> linearization</p>
        </span>
</div>

<p>In the picture below the sRGB colors from the source and destination are linearized, composited, and then converted back to non-linear encoding for display. This is how those colors should actually look:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_blend_lin.svg"
         alt="Composition of two colors against a white background with linearization" width="405" height="133"
    /> 
    </div><span>
            <p>Composition of two colors against a white background <em>with</em> linearization</p>
        </span>
</div>

<p>We&rsquo;ve now introduced a discrepancy that goes against the expectations. The only way to achieve the visual parity using that method is to pick all the colors using linear values, but those are quite different than what everyone is used to. A 50% gray with linear values looks like 73.5% sRGB gray.</p>
<p>Additionally, special care has to be taken when dealing with premultiplied alpha. The premultiplication should happen on the <em>linear</em> values, i.e. before then non-linear encoding happens. This will cause the linearization step to correctly end up with proper alpha premultiplied linear values.</p>
<h1 id="premultiplied-alpha-and-bit-depth">Premultiplied Alpha and Bit Depth<a href="index.html#premultiplied-alpha-and-bit-depth" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>While very useful for compositing, filtering, and interpolation, premultiplied alpha isn&rsquo;t a silver bullet and has some drawbacks. The biggest one is the reduction of bit-depth of representable colors. Let&rsquo;s think about an 8-bit encoding of value 150 that is premultiplied by 20% alpha. After alpha premultiplication we get</p>
<div class="alpha_equation">
round(150 &times; 0.2) = 30
</div>
<p>If we repeat the same procedure for a value of 151 we get:</p>
<div class="alpha_equation">
round(151 &times; 0.2) = 30
</div>
<p>The encoded value is the same despite the difference in the input value. In fact, values 148, 149, 150, 151, and 152 end up being encoded as 30 after alpha premultiplication, the original distinction between those five unique numbers is lost:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/alpha_premul_bits.svg"
         alt="Premultiplication by 20% alpha collapses different 8-bit values into the same one" width="560" height="203"
    /> 
    </div><span>
            <p>Premultiplication by 20% alpha collapses different 8-bit values into the same one</p>
        </span>
</div>

<p>Naturally, the lower the alpha the more severe the effect is. From the possible range of 256<sup>4</sup> (roughly 4.3 billion) different combinations of 8-bit RGBA values only 25.2% of them end up having unique representation after premultiplication, we&rsquo;re effectively wasting almost 2 bits of the 32 bit range.</p>
<p>Transformation of colors between various color spaces often requires the color components to be un-premultiplied, that is divided by the alpha component, to get the original intensity of the color. That step is mandatory due to already mentioned common non-linear nature of the encoding. The existence of premultiplication reduces the accuracy of color representation and the conversions between color spaces may be imperfect.</p>
<p>In practice the reduction of bit depth is rarely important, especially when it comes to compositing. The lower the alpha value the less visible the color is and the less impactful its compositing becomes. If you&rsquo;re aiming for pedantically accurate operations on colors you wouldn&rsquo;t be using 8-bit representation in the first place – the <a href="../exposing-floating-point/index.html">floating point</a> formats are much better suited for this purpose.</p>
<h1 id="further-reading">Further Reading<a href="index.html#further-reading" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>The concept of an alpha channel was created by <a href="https://en.wikipedia.org/wiki/Alvy_Ray_Smith">Alvy Ray</a> and <a href="https://en.wikipedia.org/wiki/Edwin_Catmull">Ed Catmull</a> – the cofounders of Pixar. The former&rsquo;s <a href="http://alvyray.com/Memos/CG/Microsoft/7_alpha.pdf">Alpha and the History of Digital Compositing</a> describes the history of the invention and origins of the name &ldquo;alpha&rdquo;, while also showing how those concepts built on and significantly surpassed the <a href="https://en.wikipedia.org/wiki/Matte_(filmmaking)">matting</a> used in filmmaking.</p>
<p>For a detailed discussion of the meaning of alpha I highly recommend Andrew Glassner&rsquo;s <a href="http://jcgt.org/published/0004/02/03/paper.pdf">Interpreting Alpha</a>. His paper provides a rigorous, but very readable mathematical derivation of alpha as an interaction between opacity and coverage.</p>
<p>Finally, for a thorough discourse on premultiplied alpha you can&rsquo;t go wrong with <a href="http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/">GPUs prefer premultiplication</a> by Eric Haines. He not only provides a great overview of the issues caused by <em>not</em> premultiplying, especially as they relate to 3D rendering, but also links to a bunch of other articles that discuss the problem.</p>
<h1 id="final-words">Final Words<a href="index.html#final-words" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>This article originally started as a simple exposé of Porter-Duff compositing operators, but all the other concepts related to alpha compositing were just too interesting to leave by.</p>
<p>One thing I particularly like about the alpha is that it&rsquo;s just an extra number that accompanies the RGB components, yet it opens up so many unique rendering opportunities. It literally created a new dimension of what could be achieved in the plain old world of compositing and 2D rendering.</p>
<p>The next time you look at smooth edges of vector shapes, or you notice a dark overlay making some parts of a user interface dimmer, remember it&rsquo;s just a small but mighty powerful component making it all possible.</p>

    </div>
</div>
      </div>
    </div>
    <div id="footer">
        
<div class="article_footer">
If you enjoy these articles, consider supporting on <a href="https://www.patreon.com/ciechanowski">Patreon</a>.
</div>
Copyright &copy; 2024 Bartosz Ciechanowski
    </div>
  </div>
</body>

</html>