<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="theme-color" content="#2052BB">
<meta name="author" content="Bartosz Ciechanowski">
<meta name="format-detection" content="telephone=no">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-25335284-3"></script>


<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-25335284-3');
</script>
  <meta property="og:title" content="Exposing NSDictionary – Bartosz Ciechanowski" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ciechanow.ski/exposing-nsdictionary/" />
<meta property="og:description" content="" />
<meta property="og:locale" content="en_US">
  <link href="../css/base.css?2fdf9770" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Lato:700&display=swap" rel="stylesheet" type="text/css" async>
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,500&display=swap" rel="stylesheet" async>
  <title>Exposing NSDictionary – Bartosz Ciechanowski</title>
  <link rel="icon" href="../favicon.ico">
  <link href="../css/syntax.css" rel="stylesheet" type="text/css" />
  <script defer src="../js/base.js?ec479c57"></script>
</head>

<body>
  <div id="main_container">
    <div id="body">
      <div id="banner">
    <div id="banner_wrapper">
        <div id="banner_content">
            <div id="site_title">
                <a href="../index.html">Bartosz Ciechanowski</a>
            </div>
            <div id="navigation">
                <a href="../index.html">Blog</a>
                <a href="../archives.html">Archives</a>
            </div>
            <div id="social">
                <a class="patreon" href="https://www.patreon.com/ciechanowski" title="Patreon"><div class="patreonLogo">Patreon</div></a>
                <a class="twitter" href="https://twitter.com/bciechanowski" title="X / Twitter"><div class="twitterLogo">X / Twitter</div></a>
                <a class="instagram" href="https://www.instagram.com/bartoszciechanowski/" title="Instagram"><div class="igLogo">Instagram</div></a>
                <a class="email" href="mailto:bartosz@ciechanow.ski" title="e-mail"><div class="emailLogo">e-mail</div></a>
                <a class="rss" href="../atom.xml" title="RSS"><div class="rssLogo">RSS</div></a>
            </div>
        </div>
    </div>
</div>

      <div id="content">
        
<div class="article">
    <div class="post_date">April 8, 2014</div>
    <h1 class="post_title"><a href="../exposing-nsdictionary/index.html">Exposing NSDictionary</a></h1>
    <div class="padding_wrapper"><p>Hash tables are just awesome. To this day I find it fascinating that one can fetch an object corresponding to an arbitrary key in constant time. Although iOS 6.0 introduced an <a href="http://nshipster.com/nshashtable-and-nsmaptable/">explicit hash table</a>, it is <code>NSDictionary</code> that&rsquo;s almost exclusively used for associative storage.</p>
<p><code>NSDictionary</code> doesn&rsquo;t make any promise of its internal implementation. It would make little sense for a dictionary to store its data in a completely random fashion. However, this assumption doesn&rsquo;t answer the key question: does <code>NSDictionary</code> make use of a hash table? This is what I&rsquo;ve decided to investigate.</p>
<p>Why not to tackle the full featured <code>NSMutableDictionary</code>? A mutable dictionary is, understandably, much more complex and the amount of disassembly I would have had to go through was terrifying. Regular <code>NSDictionary</code> still provided a nontrivial ARM64 deciphering challenge. Despite being immutable, the class has some very interesting implementation details which should make the following ride enjoyable.</p>
<p>This blog post has a <a href="https://github.com/Ciechan/NSDictionaryExplorer">companion repo</a> which contains discussed pieces of code. While the entire investigation has been based on the iOS 7.1 SDK targeting a 64-bit device, neither iOS 7.0 nor 32-bit devices impact the findings.</p>
<h1 id="the-class">The Class<a href="../exposing-nsdictionary/index.html#the-class" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Plenty of Foundation classes are class clusters and <code>NSDictionary</code> is no exception. For quite a long time <code>NSDictionary</code> used <code>CFDictionary</code> as its default implementation, however, starting with iOS 6.0 things have changed:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">(lldb) po [[NSDictionary new] class]
__NSDictionaryI
</code></pre></div><p>Similarly to <code>__NSArrayM</code>, <code>__NSDictionaryI</code> rests within the CoreFoundation framework, in spite of being publicly presented as a part of Foundation. Running the library through class-dump generates the following ivar layout:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">__NSDictionaryI</span> : <span class="nc">NSDictionary</span>
<span class="p">{</span>
    <span class="n">NSUInteger</span> <span class="nl">_used</span><span class="p">:</span><span class="mi">58</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="nl">_szidx</span><span class="p">:</span><span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>It&rsquo;s surprisingly short. There doesn&rsquo;t seem to be any pointer to either keys or objects storage. As we will soon see, <code>__NSDictionary</code> literally keeps its storage to itself.</p>
<h1 id="the-storage">The Storage<a href="../exposing-nsdictionary/index.html#the-storage" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<h2 id="instance-creation">Instance Creation<a href="../exposing-nsdictionary/index.html#instance-creation" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>To understand where <code>__NSDictionaryI</code> keeps its contents, let&rsquo;s take a quick tour through the instance creation process. There is just one class method that&rsquo;s responsible for spawning new instances of <code>__NSDictionaryI</code>. According to class-dump, the method has the following signature:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">__new:</span><span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="nv">arg1</span><span class="o">:</span><span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="nl">arg2</span><span class="p">:(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="nl">arg3</span><span class="p">:(</span><span class="n">_Bool</span><span class="p">)</span><span class="nl">arg4</span><span class="p">:(</span><span class="n">_Bool</span><span class="p">)</span><span class="n">arg5</span><span class="p">;</span>
</code></pre></div><p>It takes five arguments, of which only the first one is named. If you were to use it in a <code>@selector</code> statement it would have a form of <code>@selector(__new:::::)</code>. The first three arguments are easily inferred by setting a breakpoint on this method and peeking into the contents of <code>x2</code>, <code>x3</code> and <code>x4</code> registers which contain the array of keys, array of objects, and number of keys (objects) respectively. Notice, that keys and objects arrays are swapped in comparison to the public facing API which takes a form of:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">dictionaryWithObjects:</span><span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="p">[])</span><span class="nv">objects</span> <span class="nf">forKeys:</span><span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span> <span class="p">[])</span><span class="nv">keys</span> <span class="nf">count:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">cnt</span><span class="p">;</span>
</code></pre></div><p>It doesn&rsquo;t matter whether an argument is defined as <code>const id *</code> or <code>const id []</code> since <a href="http://c-faq.com/aryptr/aryptrparam.html">arrays decay into pointers</a> when passed as function arguments.</p>
<p>With three arguments covered we&rsquo;re left with the two unidentified boolean parameters. I&rsquo;ve done some assembly digging with the following results: the fourth argument governs whether the keys should be copied, and the last one decides whether the arguments should <em>not</em> be retained. We can now rewrite the method with named parameters:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">__new:</span><span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="nv">keys</span> <span class="o">:</span><span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="nl">objects</span> <span class="p">:(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="nl">count</span> <span class="p">:(</span><span class="n">_Bool</span><span class="p">)</span><span class="nl">copyKeys</span> <span class="p">:(</span><span class="n">_Bool</span><span class="p">)</span><span class="n">dontRetain</span><span class="p">;</span>
</code></pre></div><p>Unfortunately, we don&rsquo;t have explicit access to this private method, so by using the regular means of allocation the last two arguments are always set to <code>YES</code> and <code>NO</code> respectively. It is nonetheless interesting that <code>__NSDictionaryI</code> is capable of a more sophisticated keys and objects control.</p>
<h2 id="indexed-ivars">Indexed ivars<a href="../exposing-nsdictionary/index.html#indexed-ivars" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Skimming through the disassembly of <code>+ __new:::::</code> reveals that both <code>malloc</code> and <code>calloc</code> are nowhere to be found. Instead, the method calls into <code>__CFAllocateObject2</code> passing the <code>__NSDictionaryI</code> class as first argument and requested storage size as a second. Stepping down into the sea of ARM64 shows that the first thing <code>__CFAllocateObject2</code> does is call into <code>class_createInstance</code> with the exact same arguments.</p>
<p>Fortunately, at this point we have access to <a href="https://opensource.apple.com/source/objc4/objc4-551.1/">the source code</a> of Objective-C runtime which makes further investigation much easier.</p>
<p>The <code>class_createInstance(Class cls, size_t extraBytes)</code> function merely calls into <code>_class_createInstanceFromZone</code> passing <code>nil</code> as a zone, but this is the final step of object allocation. While the function itself has many additional checks for different various circumstances, its gist can be covered with just three lines:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">_class_createInstanceFromZone</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">extraBytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">alignedInstanceSize</span><span class="p">()</span> <span class="o">+</span> <span class="n">extraBytes</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The <code>extraBytes</code> argument couldn&rsquo;t have been more descriptive. It&rsquo;s literally the number of extra bytes that inflate the default instance size. As an added bonus, notice that it&rsquo;s the <code>calloc</code> call that ensures all the ivars are zeroed out when the object gets allocated.</p>
<p>The indexed ivars section is nothing more than an additional space that sits at the end of regular ivars:


<div class="img_container">
    <div class="img_border">
    <img src="../images/dictionaryIndexedIvars@2x.jpg"
         alt="Allocating objects"width="506px"height="299px"
    /> 
    </div><span>
            <p>Allocating objects</p>
        </span>
</div>
</p>
<p>Allocating space on its own doesn&rsquo;t sound very thrilling so the runtime publishes an accessor:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="kt">void</span> <span class="o">*</span><span class="n">object_getIndexedIvars</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span>
</code></pre></div><p>There is no magic whatsoever in this function, it just returns a pointer to the beginning of indexed ivars section:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/dictionaryGetIndexedIvars@2x.jpg"
         alt="Indexed ivars section"width="584px"height="287px"
    /> 
    </div><span>
            <p>Indexed ivars section</p>
        </span>
</div>

<p>There are few cool things about indexed ivars. First of all, each instance can have <em>different</em> amount of extra bytes dedicated to it. This is exactly the feature <code>__NSDictionaryI</code> uses.</p>
<p>Secondly, they provide faster access to the storage. It all comes down to being <a href="http://stackoverflow.com/a/16699282/558816">cache-friendly</a>. Generally speaking, jumping to random memory locations (by dereferencing a pointer) can be expensive.  Since the object has just been accessed (somebody has called a method on it), it&rsquo;s very likely that its indexed ivars have landed in cache. By keeping everything that&rsquo;s needed very close, the object can provide as good performance as possible.</p>
<p>Finally, indexed ivars can be used as a crude defensive measure to make object&rsquo;s internals invisible to the utilities like class-dump. This is a very basic protection since a dedicated attacker can simply look for <code>object_getIndexedIvars</code> calls in the disassembly or randomly probe the instance past its regular ivars section to see what&rsquo;s going on.</p>
<p>While powerful, indexed ivars come with two caveats. First of all, <code>class_createInstance</code> can&rsquo;t be used under ARC, so you&rsquo;ll have to compile some parts of your class with <code>-fno-objc-arc</code> flag to make it shine. Secondly, the runtime doesn&rsquo;t keep the indexed ivar size information anywhere. Even though <code>dealloc</code> will clean everything up (as it calls <code>free</code> internally), you should keep the storage size somewhere, assuming you use <em>variable</em> number of extra bytes.</p>
<h1 id="looking-for-key-and-fetching-object">Looking for Key and Fetching Object<a href="../exposing-nsdictionary/index.html#looking-for-key-and-fetching-object" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<h2 id="analyzing-assembly">Analyzing Assembly<a href="../exposing-nsdictionary/index.html#analyzing-assembly" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Although at this point we could poke the <code>__NSDictionaryI</code> instances to figure out how they work, the ultimate truth lies within the assembly. Instead of going through the entire wall of ARM64 we will discuss the equivalent Objective-C code instead.</p>
<p>The class itself implements very few methods, but I claim the most important is <code>objectForKey:</code> – this is what we&rsquo;re going to discuss in more detail. Since I made the assembly analysis anyway, you can read it on <a href="../extra/objectforkeyassembly/index.html">a separate page</a>. It&rsquo;s dense, but the thorough pass should convince you the following code is more or less correct.</p>
<h2 id="the-c-code">The C Code<a href="../exposing-nsdictionary/index.html#the-c-code" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Unfortunately, I don&rsquo;t have access to the Apple&rsquo;s code base, so the reverse-engineered code below is not <em>identical</em> to the original implementation. On the other hand, it seems to be working well and I&rsquo;ve yet to find an edge case that behaves differently in comparison to the genuine method.</p>
<p>The following code is written from the perspective of <code>__NSDictionaryI</code> class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">objectForKey:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">aKey</span>
<span class="p">{</span>
    <span class="n">NSUInteger</span> <span class="n">sizeIndex</span> <span class="o">=</span> <span class="n">_szidx</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="n">size</span> <span class="o">=</span> <span class="n">__NSDictionarySizes</span><span class="p">[</span><span class="n">sizeIndex</span><span class="p">];</span>
    
    <span class="kt">id</span> <span class="o">*</span><span class="n">storage</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">object_getIndexedIvars</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    
    <span class="n">NSUInteger</span> <span class="n">fetchIndex</span> <span class="o">=</span> <span class="p">[</span><span class="n">aKey</span> <span class="n">hash</span><span class="p">]</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">id</span> <span class="n">fetchedKey</span> <span class="o">=</span> <span class="n">storage</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fetchIndex</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fetchedKey</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">fetchedKey</span> <span class="o">==</span> <span class="n">aKey</span> <span class="o">||</span> <span class="p">[</span><span class="n">fetchedKey</span> <span class="nl">isEqual</span><span class="p">:</span><span class="n">aKey</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">storage</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fetchIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">fetchIndex</span><span class="o">++</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">fetchIndex</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fetchIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><p>When you take a closer look at the C code you might notice something strange about key fetching. It&rsquo;s always taken from even offsets, while the returned object is at the very next index. This is the dead giveaway of <code>__NSDictionaryI</code>&rsquo;s internal storage – it keeps keys and objects alternately:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/dictionaryLayout@2x.jpg"
         alt="Keys and objects are stored alternately"width="235px"height="322px"
    /> 
    </div><span>
            <p>Keys and objects are stored alternately</p>
        </span>
</div>

<p><strong>Update:</strong> Joan Lluch <a href="../exposing-nsdictionary/index.html#comment-1345004966">provided</a> a very convincing explanation for this layout. The original code could use an array of very simple structs:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="k">struct</span> <span class="n">KeyObjectPair</span> <span class="p">{</span>
    <span class="kt">id</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">id</span> <span class="n">object</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>The <code>objectForKey:</code> method is very straightforward and I highly encourage you to walk through it in your head. It&rsquo;s nonetheless worth pointing out a few things. First of all, the <code>_szidx</code> ivar is used as an index into the <code>__NSDictionarySizes</code> array, thus it most likely stands for &ldquo;size index&rdquo;.</p>
<p>Secondly, the only method called on the passed key is <code>hash</code>. The reminder of dividing key&rsquo;s hash value by dictionary&rsquo;s size is used to calculate the offset into the index ivars section.</p>
<p>If the key at the offset is <code>nil</code>, we simply return <code>nil</code>, the job is done:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/dictionaryMiss@2x.jpg"
         alt="When the key slot is empty, nil is returned"width="710px"height="388px"
    /> 
    </div><span>
            <p>When the key slot is empty, nil is returned</p>
        </span>
</div>

<p>However, if the key at the offset is non <code>nil</code>, then the two cases may occur. If the keys are equal, then we return the adjacent object. If they&rsquo;re not equal then the hash collision occurred and we have to keep looking further. <code>__NSDictionaryI</code> simply keeps looking until either match or <code>nil</code> is found:</p>


<div class="img_container">
    <div class="img_border">
    <img src="../images/dictionaryHit@2x.jpg"
         alt="Key found after one collision"width="712px"height="388px"
    /> 
    </div><span>
            <p>Key found after one collision</p>
        </span>
</div>

<p>This kind of searching is known as <a href="http://en.wikipedia.org/wiki/Linear_probing">linear probing</a>. Notice how <code>__NSDictionaryI</code> wraps the <code>fetchIndex</code> around when the storage end is hit. The <code>for</code> loop is there to limit the number of checks – if the storage was full and the loop condition was missing we&rsquo;d keep looking forever.</p>
<h2 id="__nsdictionarysizes--__nsdictionarycapacities">__NSDictionarySizes &amp; __NSDictionaryCapacities<a href="../exposing-nsdictionary/index.html#__nsdictionarysizes--__nsdictionarycapacities" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>We already know <code>__NSDictionarySizes</code> is some kind of array that stores different possible sizes of <code>__NSDictionaryI</code>. We can reason that it&rsquo;s an array of <code>NSUInteger</code>s and indeed, if we ask Hopper to treat the values as 64-bit unsigned integers it suddenly makes a lot of sense:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">___NSDictionarySizes</span><span class="o">:</span>
<span class="mh">0x00000000001577a8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000000</span>
<span class="mh">0x00000000001577b0</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000003</span>
<span class="mh">0x00000000001577b8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000007</span>
<span class="mh">0x00000000001577c0</span>         <span class="n">dq</span>         <span class="mh">0x000000000000000d</span>
<span class="mh">0x00000000001577c8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000017</span>
<span class="mh">0x00000000001577d0</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000029</span>
<span class="mh">0x00000000001577d8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000047</span>
<span class="mh">0x00000000001577e0</span>         <span class="n">dq</span>         <span class="mh">0x000000000000007f</span>
<span class="kc">...</span>
</code></pre></div><p>In a more familiar decimal form it presents as a beautiful list of 64 primes starting with the following sequence: 0, 3, 7, 13, 23, 41, 71, 127. Notice, that those are not consecutive prime numbers which begs the question: what&rsquo;s the average ratio of the two neighboring numbers? It&rsquo;s actually around <code>1.637</code> – a very close match to the <code>1.625</code> which was the growth factor for <code>NSMutableArray</code>. For details of why primes are used for the storage size <a href="http://stackoverflow.com/a/1147232/558816">this Stack Overflow answer</a> is a good start.</p>
<p>We already know how much storage <code>__NSDictionaryI</code> can have, but how does it know which size index to pick on initialization? The answer lies within the previously mentioned <code>+ __new:::::</code> class method. Converting some parts of the assembly back to C renders the following code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="kt">int</span> <span class="n">szidx</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">szidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">szidx</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">szidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__NSDictionaryCapacities</span><span class="p">[</span><span class="n">szidx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">szidx</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The method looks linearly through <code>__NSDictionaryCapacities</code> array until <code>count</code> fits into the size. A quick glance in Hopper shows the contents of the array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">___NSDictionaryCapacities</span><span class="o">:</span>
<span class="mh">0x00000000001579b0</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000000</span>
<span class="mh">0x00000000001579b8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000003</span>
<span class="mh">0x00000000001579c0</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000006</span>
<span class="mh">0x00000000001579c8</span>         <span class="n">dq</span>         <span class="mh">0x000000000000000b</span>
<span class="mh">0x00000000001579d0</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000013</span>
<span class="mh">0x00000000001579d8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000020</span>
<span class="mh">0x00000000001579e0</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000034</span>
<span class="mh">0x00000000001579e8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000055</span>
<span class="kc">...</span>
</code></pre></div><p>Converting to base-10 provides 0, 3, 6, 11, 19, 32, 52, 85 and so on. Notice that those are <em>smaller</em> numbers than the primes listed before. If you were to fit 32 key-value pairs into <code>__NSDictionaryI</code> it will allocate space for 41 pairs, conservatively saving quite a few empty slots. This helps reducing the number of hash collisions, keeping the fetching time as close to constant as possible. Apart from trivial case of 3 elements, <code>__NSDictionaryI</code> will never have its storage full, on average filling at most 62% of its space.</p>
<p>As a trivia, the last nonempty value of <code>__NSDictionaryCapacities</code> is 0x11089481C742 which is 18728548943682 in base-10. You&rsquo;d have to try really hard to <em>not</em> fit within the pairs count limit, at least on 64-bit architectures.</p>
<h3 id="non-exported-symbols">Non Exported Symbols<a href="../exposing-nsdictionary/index.html#non-exported-symbols" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h3>
<p>If you were to use <code>__NSDictionarySizes</code> in your code by declaring it as an <code>extern</code> array, you&rsquo;d quickly realize it&rsquo;s not that easy. The code wouldn&rsquo;t compile due to a linker error – the <code>__NSDictionarySizes</code> symbol is undefined. Inspecting the CoreFoundation library with nm utility:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">nm CoreFoundation <span class="p">|</span> grep ___NSDictionarySizes
</code></pre></div><p>&hellip;clearly shows the symbols are there (for ARMv7, ARMv7s and ARM64 respectively):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">00139c80 s ___NSDictionarySizes
0013ac80 s ___NSDictionarySizes
0000000000156f38 s ___NSDictionarySizes
</code></pre></div><p>Unfortunately the nm manual clearly states:</p>
<blockquote>
<p>If the symbol is local (non-external), the symbol&rsquo;s type is instead represented  by  the corresponding  lowercase letter.</p>
</blockquote>
<p>The symbols for <code>__NSDictionarySizes</code> are simply not exported – they&rsquo;re intended for internal use of the library. I&rsquo;ve done some research to figure out if it&rsquo;s possible to link with non-exported symbols, but apparently it is not (<em>please</em> tell me if it is!). We can&rsquo;t access them. That is to say, we can&rsquo;t access them easily.</p>
<h3 id="sneaking-in">Sneaking in<a href="../exposing-nsdictionary/index.html#sneaking-in" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h3>
<p>Here&rsquo;s an interesting observation: in both iOS 7.0 an 7.1 the <code>kCFAbsoluteTimeIntervalSince1904</code> constant is laid out directly <em>before</em> <code>__NSDictionarySizes</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">_kCFAbsoluteTimeIntervalSince1904</span><span class="o">:</span>
<span class="mh">0x00000000001577a0</span>         <span class="n">dq</span>         <span class="mh">0x41e6ceaf20000000</span>
<span class="n">___NSDictionarySizes</span><span class="o">:</span>
<span class="mh">0x00000000001577a8</span>         <span class="n">dq</span>         <span class="mh">0x0000000000000000</span>
</code></pre></div><p>The best thing about <code>kCFAbsoluteTimeIntervalSince1904</code> is that it <em>is</em> exported! We&rsquo;re going to add 8 bytes (size of <code>double</code>) to the address of this constant and reinterpret the result as pointer to <code>NSUInteger</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="n">NSUInteger</span> <span class="o">*</span><span class="n">Explored__NSDictionarySizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kCFAbsoluteTimeIntervalSince1904</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
</code></pre></div><p>Then we can access its values by convenient indexing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="n">Explored__NSDictionarySizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span> <span class="err">$</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="n">Explored__NSDictionarySizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="n">Explored__NSDictionarySizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div><p>This hack is very fragile and will most likely break in the future, but this is a test project so it&rsquo;s perfectly fine.</p>
<h1 id="__nsdictionaryi-characteristics">__NSDictionaryI Characteristics<a href="../exposing-nsdictionary/index.html#__nsdictionaryi-characteristics" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>Now that we&rsquo;ve discovered the internal structure of <code>__NSDictionaryI</code> we can use this information to figure out why things work they way they work and what unforeseen consequences the present implementation of <code>__NSDictionaryI</code> introduces.</p>
<h2 id="printout-code">Printout Code<a href="../exposing-nsdictionary/index.html#printout-code" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>To make our investigation a little bit easier we will create a helper <code>NSDictionary</code> category method that will print the contents of the instance</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">explored_description</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">([</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&#34;__NSDictionaryI&#34;</span><span class="p">]);</span>
    
    <span class="n">BCExploredDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="p">(</span><span class="n">BCExploredDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">;</span>

    <span class="n">NSUInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">_used</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="n">sizeIndex</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">_szidx</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Explored__NSDictionarySizes</span><span class="p">[</span><span class="n">sizeIndex</span><span class="p">];</span>
    
    <span class="n">__unsafe_unretained</span> <span class="kt">id</span> <span class="o">*</span><span class="n">storage</span> <span class="o">=</span> <span class="p">(</span><span class="n">__unsafe_unretained</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">object_getIndexedIvars</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    
    <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nl">stringWithString</span><span class="p">:</span><span class="s">@&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">];</span>
    
    <span class="p">[</span><span class="n">description</span> <span class="nl">appendFormat</span><span class="p">:</span><span class="s">@&#34;Count: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">count</span><span class="p">];</span>
    <span class="p">[</span><span class="n">description</span> <span class="nl">appendFormat</span><span class="p">:</span><span class="s">@&#34;Size index: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sizeIndex</span><span class="p">];</span>
    <span class="p">[</span><span class="n">description</span> <span class="nl">appendFormat</span><span class="p">:</span><span class="s">@&#34;Size: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">description</span> <span class="nl">appendFormat</span><span class="p">:</span><span class="s">@&#34;[%d] %@ - %@</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="n">storage</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="n">description</span><span class="p">],</span> <span class="p">[</span><span class="n">storage</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="n">description</span><span class="p">]];</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">description</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="order-of-keysobjects-on-enumeration-is-the-same-as-order-of-keysobjects-in-storage">Order of keys/objects on enumeration is the same as order of keys/objects in storage<a href="../exposing-nsdictionary/index.html#order-of-keysobjects-on-enumeration-is-the-same-as-order-of-keysobjects-in-storage" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Let&rsquo;s create a simple dictionary containing four values:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="l">@{</span><span class="mi">@1</span> <span class="o">:</span> <span class="s">@&#34;Value 1&#34;</span><span class="p">,</span>
                       <span class="mi">@2</span> <span class="o">:</span> <span class="s">@&#34;Value 2&#34;</span><span class="p">,</span>
                       <span class="mi">@3</span> <span class="o">:</span> <span class="s">@&#34;Value 3&#34;</span><span class="p">,</span>
                       <span class="mi">@4</span> <span class="o">:</span> <span class="s">@&#34;Value 4&#34;</span><span class="l">}</span><span class="p">;</span>

<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">dict</span> <span class="n">explored_description</span><span class="p">]);</span>
</code></pre></div><p>The output of the explored description is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">Count: 4
Size index: 2
Size: 7
[0] (null) - (null)
[1] 3 - Value 3
[2] (null) - (null)
[3] 2 - Value 2
[4] (null) - (null)
[5] 1 - Value 1
[6] 4 - Value 4
</code></pre></div><p>With that in mind let&rsquo;s do a quick enumeration over dictionary:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="p">[</span><span class="n">dict</span> <span class="nl">enumerateKeysAndObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@ - %@&#34;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
<span class="p">}];</span>
</code></pre></div><p>And the output:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">3 - Value 3
2 - Value 2
1 - Value 1
4 - Value 4
</code></pre></div><p>Enumeration seems to simply walk through the storage, ignoring the <code>nil</code> keys and calling the block only for non-empty slots. This is also the case for fast enumeration, <code>keyEnumerator</code>, <code>allKeys</code> and <code>allValues</code> methods. It makes perfect sense. The <code>NSDictionary</code> is not ordered, so it doesn&rsquo;t really matter what sequence the keys and values are provided in. Using the internal layout is the easiest and probably the fastest option.</p>
<h2 id="if-you-mess-up-__nsdictionaryi-may-return-something-for-nil-key">If you mess up, __NSDictionaryI may return something for nil key!<a href="../exposing-nsdictionary/index.html#if-you-mess-up-__nsdictionaryi-may-return-something-for-nil-key" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Let&rsquo;s consider an example. Imagine we&rsquo;re building a simple 3D strategy game set in space. The entire universe is split into cube-like sectors that imaginary factions can fight over. A sector can be referenced by its <code>i</code>, <code>j</code>, and <code>k</code> indexes. We shouldn&rsquo;t use a 3D array to store the sectors info – the game space is huge and most of it is empty, so we would waste memory storing <code>nil</code> pointers. Instead, we&rsquo;re going to use a sparse storage in a form of <code>NSDictionary</code> with a custom key class that will make it super easy to query if there is something at a given location.</p>
<p>Here&rsquo;s the interface for key, a <code>BC3DIndex</code> class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">BC3DIndex</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span> <span class="c1">// you actually can do that
</span><span class="c1"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithI:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">i</span> <span class="nf">j:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">j</span> <span class="nf">k:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">k</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></div><p>And its equally trivial implementation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">BC3DIndex</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithI:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">i</span> <span class="nf">j:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">j</span> <span class="nf">k:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">k</span>
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_j</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">_k</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="n">BC3DIndex</span> <span class="o">*</span><span class="p">)</span><span class="nv">other</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">_i</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">.</span><span class="n">j</span> <span class="o">==</span> <span class="n">_j</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">.</span><span class="n">k</span> <span class="o">==</span> <span class="n">_k</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_i</span> <span class="o">^</span> <span class="n">_j</span> <span class="o">^</span> <span class="n">_k</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span> <span class="c1">// we&#39;re immutable so it&#39;s OK
</span><span class="c1"></span><span class="p">}</span>

<span class="k">@end</span>
</code></pre></div><p>Notice how we&rsquo;re being a good subclassing citizen: we implemented both <code>isEqual:</code> and <code>hash</code> methods and made sure that if two 3D-indexes are equal then their hash values are equal as well. The object equality requirements <em>are</em> fulfilled.</p>
<p>Here&rsquo;s a trivia: what will the following code print?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">indexes</span> <span class="o">=</span> <span class="l">@{</span><span class="p">[[</span><span class="n">BC3DIndex</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithI</span><span class="p">:</span><span class="mi">2</span> <span class="nl">j</span><span class="p">:</span><span class="mi">8</span> <span class="nl">k</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">:</span> <span class="s">@&#34;A black hole!&#34;</span><span class="p">,</span>
                          <span class="p">[[</span><span class="n">BC3DIndex</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithI</span><span class="p">:</span><span class="mi">0</span> <span class="nl">j</span><span class="p">:</span><span class="mi">0</span> <span class="nl">k</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="s">@&#34;Asteroids!&#34;</span><span class="p">,</span>
                          <span class="p">[[</span><span class="n">BC3DIndex</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithI</span><span class="p">:</span><span class="mi">4</span> <span class="nl">j</span><span class="p">:</span><span class="mi">3</span> <span class="nl">k</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">:</span> <span class="s">@&#34;A planet!&#34;</span><span class="l">}</span><span class="p">;</span>

<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">indexes</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="nb">nil</span><span class="p">]);</span>
</code></pre></div><p>It should be <code>(null)</code> right? Nope:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">Asteroids!
</code></pre></div><p>To investigate this further let&rsquo;s grab a dictionary&rsquo;s description:</p>
<pre tabindex="0"><code class="language-c-objdump" data-lang="c-objdump">Count: 3
Size index: 1
Size: 3
[0] &lt;BC3DIndex: 0x17803d340&gt; - A black hole!
[1] &lt;BC3DIndex: 0x17803d360&gt; - Asteroids!
[2] &lt;BC3DIndex: 0x17803d380&gt; - A planet!
</code></pre><p>It turns out <code>__NSDictionaryI</code> doesn&rsquo;t check if the <code>key</code> passed into <code>objectForKey:</code> is <code>nil</code> (and I argue this is a <em>good</em> design decision). Calling <code>hash</code> method on <code>nil</code> returns <code>0</code>, which causes the class to compare key at index <code>0</code> with <code>nil</code>. This is important: it is the <em>stored</em> key that executes the <code>isEqual:</code> method, not the passed in key.</p>
<p>The first comparison fails, since <code>i</code> index for &ldquo;A black hole!&rdquo; is <code>2</code> whereas for <code>nil</code> it&rsquo;s zero. The keys are not equal which causes the dictionary to keep looking, hitting another stored key: the one for &ldquo;Asteroids!&rdquo;. This key has all three <code>i</code>, <code>j</code>, and <code>k</code> properties equal to <code>0</code> which is also what <code>nil</code> will return when asked for its properties (by the means of <code>nil</code> check inside <code>objc_msgSend</code>).</p>
<p>This is the crux of the problem. The <code>isEqual:</code> implementation of <code>BC3DIndex</code> may, under some conditions, return <code>YES</code> for <code>nil</code> comparison. As you can see, this is a very dangerous behavior that can mess things up easily. <em>Always</em> ensure that your object is not equal to <code>nil</code>.</p>
<h2 id="a-helper-key-class">A Helper Key Class<a href="../exposing-nsdictionary/index.html#a-helper-key-class" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>For the next two tests we&rsquo;re going to craft a special key class that will have a configurable hash value and will print stuff to the console when executing <code>hash</code> and <code>isEqual:</code> method.</p>
<p>Here&rsquo;s the interface:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">BCNastyKey</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">hashValue</span><span class="p">;</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">keyWithHashValue:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">hashValue</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></div><p>And the implementation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">BCNastyKey</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">keyWithHashValue:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">hashValue</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">BCNastyKey</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithHashValue</span><span class="p">:</span><span class="n">hashValue</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithHashValue:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">hashValue</span>
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_hashValue</span> <span class="o">=</span> <span class="n">hashValue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Key %@ is asked for its hash&#34;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="n">description</span><span class="p">]);</span>

    <span class="k">return</span> <span class="n">_hashValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="n">BCNastyKey</span> <span class="o">*</span><span class="p">)</span><span class="nv">object</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Key %@ equality test with %@: %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="n">description</span><span class="p">],</span> <span class="p">[</span><span class="n">object</span> <span class="n">description</span><span class="p">],</span> <span class="n">object</span> <span class="o">==</span> <span class="nb">self</span> <span class="o">?</span> <span class="s">@&#34;YES&#34;</span> <span class="o">:</span> <span class="s">@&#34;NO&#34;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">object</span> <span class="o">==</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;(&amp;:%p #:%lu)&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_hashValue</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div><p>This key is awful: we&rsquo;re only equal to self, but we&rsquo;re returning an arbitrary hash. Notice that this <em>doesn&rsquo;t</em> break the equality contract.</p>
<h2 id="isequal-doesnt-have-to-be-called-to-match-the-key"><code>isEqual</code> doesn&rsquo;t have to be called to match the key<a href="../exposing-nsdictionary/index.html#isequal-doesnt-have-to-be-called-to-match-the-key" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Let&rsquo;s create a key and a dictionary:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="n">BCNastyKey</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">3</span><span class="p">];</span>
<span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="l">@{</span><span class="nl">key</span> <span class="p">:</span> <span class="s">@&#34;Hello there!&#34;</span><span class="l">}</span><span class="p">;</span>
</code></pre></div><p>The following call:</p>
<pre tabindex="0"><code class="language-c-objdump" data-lang="c-objdump">[dict objectForKey:key];
</code></pre><p>Prints this to the console:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">Key (&amp;:0x17800e240 #:3) is asked for its hash
</code></pre></div><p>As you can see, the <code>isEqual:</code> method has not been called. This is very cool! Since the vast majority of keys out there are <code>NSString</code> literals, they share <em>the same</em> address in the entire application. Even if the key is a very long literal string, the <code>__NSDictionaryI</code> won&rsquo;t run the potentially time consuming <code>isEqual:</code> method unless it absolutely has to. And since 64-bit architectures introduced tagged pointers, some instances of <code>NSNumber</code>, <code>NSDate</code> and,  <a href="https://twitter.com/Catfish_Man/status/393238389266194434">apparently</a>, <code>NSIndexPath</code> benefit from this optimization as well.</p>
<h2 id="worst-case-performance-is-linear">Worst case performance is linear<a href="../exposing-nsdictionary/index.html#worst-case-performance-is-linear" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h2>
<p>Let&rsquo;s create a very simple test case:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="n">BCNastyKey</span> <span class="o">*</span><span class="n">targetKey</span> <span class="o">=</span> <span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">36</span><span class="p">];</span>

<span class="n">NSDictionary</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="l">@{</span><span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">@1</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">:</span> <span class="mi">@2</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">15</span><span class="p">]</span> <span class="o">:</span> <span class="mi">@3</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">22</span><span class="p">]</span> <span class="o">:</span> <span class="mi">@4</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">BCNastyKey</span> <span class="nl">keyWithHashValue</span><span class="p">:</span><span class="mi">29</span><span class="p">]</span> <span class="o">:</span> <span class="mi">@5</span><span class="p">,</span>
                    <span class="nl">targetKey</span> <span class="p">:</span> <span class="mi">@6</span>
                    <span class="l">}</span><span class="p">;</span>
</code></pre></div><p>A single killer line:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objc" data-lang="objc"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Result: %@&#34;</span><span class="p">,</span> <span class="p">[[</span><span class="n">b</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">targetKey</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</code></pre></div><p>Reveals the disaster:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">Key (&amp;:0x170017640 #:36) is asked for its hash
Key (&amp;:0x170017670 #:1) equality test with (&amp;:0x170017640 #:36): NO
Key (&amp;:0x170017660 #:8) equality test with (&amp;:0x170017640 #:36): NO
Key (&amp;:0x170017680 #:15) equality test with (&amp;:0x170017640 #:36): NO
Key (&amp;:0x1700176e0 #:22) equality test with (&amp;:0x170017640 #:36): NO
Key (&amp;:0x170017760 #:29) equality test with (&amp;:0x170017640 #:36): NO
Result: 6
</code></pre></div><p>This is extremely pathological case – every single key in the dictionary has ben equality tested. Even though each hash was different, it still collided with every other key, because the keys' hashes were <a href="http://en.wikipedia.org/wiki/Modular_arithmetic#Congruence_relation">congruent modulo</a> 7, which turned out to be the storage size of the dictionary.</p>
<p>As mentioned before, notice that the last <code>isEqual:</code> test is missing. The <code>__NSDictionaryI</code> simply compared the pointers and figured out it must be the same key.</p>
<p>Should you care for this linear time fetching? Absolutely not. I&rsquo;m not that into probabilistic analysis of hash distribution, but you&rsquo;d have to be <em>extremely</em> unlucky for all your hashes to be modulo congruent to dictionary&rsquo;s size. Some collisions here and there will always happen, that is the nature of hash tables, but you will probably never run into the linear time issue yourself. That is, unless you mess up your <code>hash</code> function.</p>
<h1 id="final-words">Final Words<a href="../exposing-nsdictionary/index.html#final-words" class="hanchor" ariaLabel="Anchor"><img src="../images/anchor.png" width="16px" height="8px"/></a> </h1>
<p>I&rsquo;m fascinated how simple the <code>__NSDictionaryI</code> turned out to be. Needless to say, the class certainly serves its purpose and there&rsquo;s no need to make things excessively complex. For me, the most beautiful aspect of the implementation is the key-object-key-object layout. This is a brilliant idea.</p>
<p>If you were to take one tip from this article then I&rsquo;d go with watching out for your <code>hash</code> and <code>isEqual:</code> methods. Granted, one rarely writes custom key classes to be used in a dictionary, but those rules apply to <code>NSSet</code> as well.</p>
<p>I&rsquo;m aware that at some point in time <code>NSDictionary</code> will change and my findings will become obsolete. Internalizing the current implementation details may become a burden in the future when the memorized assumptions will no longer apply. However, right here and right now it&rsquo;s just so much fun to see how things work and hopefully you share my excitement.</p>

    </div>
</div>
      </div>
    </div>
    <div id="footer">
        
<div class="article_footer">
If you enjoy these articles, consider supporting on <a href="https://www.patreon.com/ciechanowski">Patreon</a>.
</div>
Copyright &copy; 2024 Bartosz Ciechanowski
    </div>
  </div>
</body>

</html>